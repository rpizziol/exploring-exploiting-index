

###
import pandas as pd
import spacy
import numpy as np
nlp = spacy.load('en_core_web_md') 

# TODO: add some parameters to concatenate all the files in the folder
def open_csv(filename):
    df = pd.read_csv(filename)
    return df


# TODO: add a function to clean the data or preprocess them in some way
def clean_csv(columns_to_keep, df):   
    df = df[columns_to_keep]
    return df
    


def calculate_vectors(abstract_column):
    docs = []
    for i in range(len(abstract_column)):
        doc = nlp(abstract_column[i])
        docs.append(doc.vector)
    
    return docs

from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

def calculate_cosine_distance(docs, which_method='average'):
    # Initialize a list to store the cosine distances
    distances = []

    # Compare each document with every other document
    for i in range(len(docs)):
        for j in range(i + 1, len(docs)):
            similarity_score = cosine_similarity([docs[i]], [docs[j]])
            cosine_distance = 1 - similarity_score[0][0]  # Calculate cosine distance
            distances.append(cosine_distance)

    # Compute either the average or the standard deviation of the distances
    if which_method == 'average':
        return np.mean(distances)
    elif which_method == 'std':
        return np.std(distances)
    elif which_method == 'both':
        return np.std(distances), np.mean(distances)
    else:
        raise ValueError("Invalid method. Choose 'average' or 'std'.")

### sarebbe interessante vedere all'interno della stessa area tematica: esempio blindness, qual è 
## la distanza media tra i documenti che hanno come area tematica blindness, così non si sovrappone 
## con la questione dell'interdisciplinarità 

def h_index(column_citations):
    citations = sorted(column_citations, reverse=True)
    h_index = 0
    for i in range(len(citations)):
        if citations[i] >= i+1:
            h_index = i+1
    return h_index