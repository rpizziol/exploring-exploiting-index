doi,citedby_count,description,author_names,author_ids
10.1145/3578245.3584940,0,,"Incerto, Emilio;Litoiu, Marin;Pinciroli, Riccardo",56815042800;6603658203;56938727000
10.1109/CLOUD60044.2023.00029,0,"Microservice (MS) architecture has become a popular paradigm in software engineering and has been embraced in the industry (e.g., Amazon, Netflix) for cloud-based applications with crucial performance requirements. Surprisingly, assessing how the MS designs affect performance is still a challenging issue, which is generally tackled by extensive and expensive profiling. In this paper, we propose μ P, a novel development framework for MS applications where performance can be predicted by design. μ P offers an API that automatically generates a per-formance model based on Layered Queuing Networks (LQNs) without requiring any development effort beyond writing the actual system code. The model can then be queried to predict performance metrics such as response time and utilization of individual microservices. We validate μ P on four benchmarks taken from the literature. The results show the effectiveness of μ P in accurately predicting performance due to increasing user load, vertical and horizontal scaling. We report prediction errors for response times consistently lower than 10% across a wide range of operating conditions.","Garbi, Giulio;Incerto, Emilio;Tribastone, Mirco",57202405054;56815042800;15123357400
10.1145/3437959.3459265,0,"The author claimed for the artifact associated with his paper the following ACM Reproducibility badges:(1) Artifact Available,(2) Artifact Evaluated-Functional,(3) Results Reproduced. After an in-depth review process, we agree to assign all the requested badges as we found it to meet the following requirements:i) it is uploaded on a persistent repository, accessible via a DOI; ii) it is well documented, consistent with the presented data, complete of all the necessary software sources and packages, and exercisable; iii) it is exhaustive in the reproduction of all the relevant data of the paper. Some curves in some reproduced plots are truncated, due to the computational limits imposed by the short-term deadline of the review process. Nevertheless, the overall trends are respected, and the curves are supporting the paper's claims.","Incerto, Emilio;Principe, Matteo",56815042800;57202456242
10.1145/3427921.3450245,3,"The automatic derivation of analytical performance models is an essential tool to promote a wider adoption of performance engineering techniques in practice. Unfortunately, despite the importance of such techniques, the attempts pursuing that goal in the literature either focus on the estimation of service demand parameters only or suffer from scalability issues and sub-optimality due to the intrinsic complexity of the underlying optimization methods. In this paper, we propose an efficient linear programming approach that allows to derive queuing network (QN) models from sampled execution traces. For doing so, we rely on a deterministic approximation of the average dynamic of QNs in terms of a compact system of ordinary differential equations. We encode these equations into a linear optimization problem whose decision variables can be directly related to the unknown QN parameters, i.e., service demands and routing probabilities. Using models of increasing complexity, we show the efficiency and the effectiveness of our technique in yielding models with high prediction power.","Incerto, Emilio;Napolitano, Annalisa;Tribastone, Mirco",56815042800;57197846259;15123357400
10.1109/MASCOTS50786.2020.9285947,0,"Markov chains are a useful model for the quantitative analysis of extra-functional properties of software systems such as performance, reliability, and energy consumption. However building Markov models of software systems remains a difficult task. Here we present a statistical method that learns a Markov chain directly from a program, by means of execution runs with inputs sampled by given probability distributions. Our technique is based on learning algorithms for so-called variable length Markov chains, which allow us to capture data dependency throughout execution paths by encoding part of the program history into each state of the chain. Our domain-specific adaptation exploits structural information about the program through its control-flow graph. Using a prototype implementation, we show that this approach represents a significant improvement over state-of-the-art general-purpose learning algorithms, providing accurate models in a number of benchmark programs.","Incerto, Emilio;Napolitano, Annalisa;Tribastone, Mirco",56815042800;57197846259;15123357400
10.1145/3358960.3379134,5,"It is well known that building analytical performance models in practice is difficult because it requires a considerable degree of proficiency in the underlying mathematics. In this paper, we pro- pose a machine-learning approach to derive performance models from data. We focus on queuing networks, and crucially exploit a deterministic approximation of their average dynamics in terms of a compact system of ordinary differential equations. We encode these equations into a recurrent neural network whose weights can be directly related to model parameters. This allows for an inter- pretable structure of the neural network, which can be trained from system measurements to yield a white-box parameterized model that can be used for prediction purposes such as what-if analyses and capacity planning. Using synthetic models as well as a real case study of a load-balancing system, we show the effectiveness of our technique in yielding models with high predictive power.","Garbi, Giulio;Incerto, Emilio;Tribastone, Mirco",57202405054;56815042800;15123357400
10.1007/978-3-030-61362-4_17,2,"Performance is an important non-functional property of software that has a direct impact on the end-user’s perception of quality of service since it is related to metrics such as response time, throughput, and utilization. Performance-by-construction can be defined as a development paradigm where executable code carries some kind of guarantee on its performance, as opposed to the current practice in software engineering where performance concerns are left to the later stages of the development process by means of profiling or testing. In this paper we argue that performance-by-construction techniques need to be probabilistic in nature, leveraging accurate models for the analysis. In support of this idea, here we carry out a literature review on methods that can be used as the basis of performance-by-construction development approaches. There has been significant research—reviewed elsewhere—on performance models derived from high-level software specifications such as UML diagrams or other domain-specific languages. This review, instead, focuses on methods where performance information is extracted directly from the code, a line of research that has arguably been less explored by the software performance engineering community.","Incerto, Emilio;Napolitano, Annalisa;Tribastone, Mirco",56815042800;57197846259;15123357400
10.1145/3302541.3310293,1,"This tutorial presents techniques for self-adaptive software systems that use performance models in order to achieve desired quality-of-service objectives. Main hindrances with the state of the art are the assumption of a steady-state regime to be able to use analytical solutions and the explosion of the state space which occurs when modeling software systems with stochastic processes such as Markov chains. This makes their online use difficult because the system under consideration may be in a transient regime, and the typically large cost of the analysis does not permit fast tracking of performance dynamics. We will introduce fluid models based on nonlinear ordinary differential equations as a key enabling technique to effectively approximate large-scale stochastic processes. This representation makes it possible to employ online optimization methods based on model-predictive control in order to find an assignment of the values of tunable parameters of the model steering the system toward a given performance goal. We will also show how, dually, the same techniques can be used for the online estimation of software service demands. In this tutorial we will focus on software performance models based on queuing networks, with applications to runtime auto-scaling in virtualized environments.","Incerto, Emilio;Tribastone, Mirco",56815042800;15123357400
10.1109/MASCOTS.2018.00040,6,"Accurate estimation of resource demands is one of the key challenges to be able to use queuing networks (QNs) for performance prediction, especially in cases where the profiling is to be performed through a non-intrusive system instrumentation. This problem is worsened when one needs to obtain a continuously updated model (e.g., for control and adaptation purposes) because it becomes crucial to use fast estimation methods that do not interfere with the behavior of the running system. A crucial limitation in the state of the art is the assumption that the measurement are taken from a system in the steady state regime. To the best of our knowledge, this paper presents the first approach-here developed for single-class QNs-That does not make such assumption. Our service-demand estimation technique relies on a deterministic approximation of the QN where the transient evolution of the queue lengths is modeled by means of a compact analytical representation based on a system of coupled nonlinear ordinary differential equations. We set up a moving-horizon estimation problem whereby the governing equations of the model, appropriately unfolded over a given time horizon, represent the constraints of a quadratic program that seeks to find the optimal choice of service demands that minimize the error between the measured queue lengths and the predicted ones. An extensive numerical evaluation demonstrates the efficiency and the effectiveness of our approach against the state-of-The-Art techniques for service demands estimation.","Incerto, Emilio;Napolitano, Annalisa;Tribastone, Mirco",56815042800;57197846259;15123357400
10.1007/978-3-319-96983-1_11,8,"Meeting performance targets of co-located distributed applications in virtualized environments is a challenging goal. In this context, vertical and horizontal scaling are promising techniques; the former varies the resource sharing on each individual machine, whereas the latter deals with choosing the number of virtual machines employed. State-of-the-art approaches mainly apply vertical and horizontal scaling in an isolated fashion, in particular assuming a fixed and symmetric load balancing across replicas. Unfortunately this may result unsatisfactory when replicas execute in environments with different computational resources. To overcome this limitation, we propose a novel combined runtime technique to determine the resource sharing quota and the horizontal load balancing policy in order to fulfill performance goals such as response time and throughput of co-located applications. Starting from a performance model as a multi-class queuing network, we formulate a model-predictive control problem which can be efficiently solved by linear programming. A validation performed on a shared virtualized environment hosting two real applications shows that only a combined vertical and horizontal load balancing adaptation can efficiently achieve desired performance targets in the presence of heterogeneous computational resources.","Incerto, Emilio;Tribastone, Mirco;Trubiani, Catia",56815042800;15123357400;24781277400
10.1109/ASE.2017.8115660,31,"A key challenge in software systems that are exposed to runtime variabilities, such as workload fluctuations and service degradation, is to continuously meet performance requirements. In this paper we present an approach that allows performance self-adaptation using a system model based on queuing networks (QNs), a well-assessed formalism for software performance engineering. Software engineers can select the adaptation knobs of a QN (routing probabilities, service rates, and concurrency level) and we automatically derive a Model Predictive Control (MPC) formulation suitable to continuously configure the selected knobs and track the desired performance requirements. Previous MPC approaches have two main limitations: i) high computational cost of the optimization, due to nonlinearity of the models; ii) focus on long-run performance metrics only, due to the lack of tractable representations of the QN's time-course evolution. As a consequence, these limitations allow adaptations with coarse time granularities, neglecting the system's transient behavior. Our MPC adaptation strategy is efficient since it is based on mixed integer programming, which uses a compact representation of a QN with ordinary differential equations. An extensive evaluation on an implementation of a load balancer demonstrates the effectiveness of the adaptation and compares it with traditional methods based on probabilistic model checking.","Incerto, Emilio;Tribastone, Mirco;Trubiani, Catia",56815042800;15123357400;24781277400
10.1145/3030207.3030239,9,"Nowadays embedded systems are powerful and everywhere. They implement complex functionality relying on a huge set of different hardware and software (HW/SW) architectures. In order to reduce their development effort, HW/SW Co-Design techniques are used during the entire development cycle. These techniques aim at helping designers to define a feasible hardware and software partitioning for the system in such a way that functional and non-functional requirements are fulfilled. In this context Design Space Exploration is a challenging activity since a huge number of different implementation alternatives need to be evaluated. By exploiting some intrinsic properties of the embedded system domain, in this paper we propose our vision for a novel Performance-Driven HW/SW Co-Design methodology. It combines: (i) the ""design for verifiability"" concept, suitable to model the system behaviour avoiding the state space explosion problem, and (ii) model-driven techniques to address performance issues. For this goal, we introduce the concepts underlying: (i) a novel formal modeling language and, (ii) a performance-driven verification/transformation chain.","Di Pompeo, Daniele;Incerto, Emilio;Muttillo, Vittoriano;Pomante, Luigi;Valente, Giacomo",57188727238;56815042800;56805275400;55905317800;57188678594
10.1145/2897053.2897060,13,"Quality-of-Service attributes such as performance and reliability heavily depend on the run-time conditions under which software is executed (e.g., workload fluctuation and resources availability). Therefore, it is important to design systems able to adapt their setting and behavior due to these run-time variabilities. In this paper we propose a novel approach based on queuing networks as the quantitative model to represent system configurations. To find a model that fits with continuous changes in run-time conditions we rely on an innovative combination of symbolic analysis and satisfiability modulo theory (SMT). Through symbolic analysis we represent all possible system configurations as a set of non-linear real constraints. By formulating an SMT problem we are able to devise feasible system configurations at a small computational cost. We study the effectiveness and scalability of our approach on a three-tier web system featuring different levels of redundancy.","Incerto, Emilio;Tribastone, Mirco;Trubiani, Catia",56815042800;15123357400;24781277400
10.1145/2804371.2804375,4,"Complex software systems are required to adapt dynamically to changing workloads and scenarios, while guaranteeing a set of performance objectives. This is not a trivial task, since run-time variability makes the process of devising the needed resources challenging for software designers. In this context, self-adaptation is a promising technique that work towards the specification of the most suitable system configuration, such that the system behavior is preserved while meeting performance requirements. In this paper we propose a proactive approach based on queuing networks that allows self-adaptation by predicting performance flaws and devising the most suitable system resources allocation. The queueing network model represents the system behavior and embeds the input parameters (e.g., workload) observed at run-time. We rely on fluid approximation to speed up the analysis of transient dynamics for performance indices. To support our approach we developed a tool that automatically generates simulation and fluid analysis code from an high-level description of the queueing network. An illustrative example is provided to demonstrate the effectiveness of our approach.","Incerto, Emilio;Tribastone, Mirco;Trubiani, Catia",56815042800;15123357400;24781277400
10.1109/AERO.2015.7119032,2,"This paper presents the application of a Model-Driven Engineering (MDE) approach to the aerospace domain. Specifically, it shows the Model-Driven Development (MDD) of an Integrated Development Environment (IDE) for a Domain-Specific Language (DSL) targeted to the achievement of the so called 'Spacecraft on-board software flexibility'. In fact, the goal of the presented work has been to deploy a full-featured IDE to be used for the development of the 'On-board Command Procedures' (OBCPs). The OBCPs coding is done by using the 'OBCP Definition Language' (ODL), specified by Thales Alenia Space Italy (TASI) on the basis of the requirements stated in the 'Space Engineering: Spacecraft On-board Control Procedures' ECSS standard (ECSS-E-ST-70-01, 16 April 2010). This standard does not impose specific language syntax but provides the guidelines for its specification. By following such guidelines and by exploiting some MDE technologies and tools, such as Eclipse Modeling Framework (EMF) and Xtext, it has been possible to realize an Eclipse-based IDE able to provide to the ODL developer the entire features essential in a modern environment for software development. The considered features include the 'traditional' ones as syntax-highlighting, code-completion, version-control, on-line error-checking, and also 'advanced' ones like syntactic validation, semantic validation, and integrated code compilation. Moreover, by means of the adopted MDE approach, a very large part of the IDE code has been automatically generated starting from the Extended Backus-Naur Form (EBNF) specification of the ODL grammar so allowing for the IDE developers to be more focused on validation issues and on the quality of product than on the coding activity. All this has been obtained by following the paradigm 'coding equals modeling', for which each program represents a behavioral model compliant to the meta-model specified by the grammar of the language itself. The obtained result is a professional product that satisfies all the expected requirements, but this would be just a starting point since the ultimate goal of this work is to contribute to fostering the adoption of MDE approaches in the spacecraft software domain.","Pomante, Luigi;Candia, Sante;Incerto, Emilio",55905317800;25822171300;56815042800
