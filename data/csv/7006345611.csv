doi,citedby_count,description,author_names,author_ids
10.1016/j.cose.2023.103133,0,"Physical layer security mechanisms use primitives that exploit physical properties of the communication channel to protect data. Protecting communications at the physical layer offers some advantages, e.g., in terms of reduced computations, since complex cryptographic procedures are not executed, However, these mechanisms lack a formal specification that prevent protocols and applications that use them from being verified and compared with those based on cyptography. Here we start filling this gap by providing an axiomatization of key physical layer security primitives and proposing a variant of the Dolev–Yao attacker model that takes them into account. We show that our formalization enables applying existing automatic tools for verifying security of protocols. Then, we show that these primitives are a valuable alternative and effective complement to cryptography, because they ensure confidentiality and integrity but require a lower energy consumption and often they also reduce transmission time. Finally, we characterize the specific application domains and network features that make adopting these security mechanisms particularly profitable with respect to the AES cypher.","Costa, Gabriele;Degano, Pierpaolo;Galletta, Letterio;Soderi, Simone",32067717500;7006345611;55260418300;56027760800
10.1007/978-981-19-9601-6_12,0,"In the era of the Internet of Things, it is essential to ensure that data collected by sensors and smart devices are reliable and that they are aggregated and transmitted securely to computational components. This has significant effects on the software that manages critical decisions and actuations of IoT systems, with possibly serious consequences when linked to essential services. The development of IoT applications requires suitable techniques to understand and evaluate the complexity of the design process. Here we adopt a software engineering approach where IoT applications are formally specified (specifically in the IoT-LySa process calculus) and a Control Flow Analysis (CFA) is exploited to statically predict how data will flow through the system. Hence, the CFA builds on a kind of supply chain for subsequent aggregations and use. Based on the analysis prediction, we propose a risk analysis that captures the dependencies between collected and aggregated data and critical decisions.","Bodei, Chiara;Ferrari, Gian Luigi;Galletta, Letterio;Degano, Pierpaolo",6603107885;56221627000;55260418300;7006345611
10.1016/j.cose.2022.102683,1,"Firewalls are a fundamental tool for managing and protecting computer networks. They behave according to a configuration that specifies the desired policy, i.e., which packets are allowed to enter a network, possibly with modified addresses. Several tools allow the user to specify policies in various high level languages, and to compile them into different target configuration languages, as well as to automatically migrate a configuration from a system to another. Often, these tools implicitly assume that the target system can enforce any desired policy. Unexpectedly, we find that this is not always the case. In particular, we show that the most common UNIX firewall systems, i.e., iptables, ipfw, pf, are not equally expressive, in that some policies can be implemented in one system but not in another. Here, we formally investigate the expressive power of these firewall systems using techniques from programming language semantics, and set up a formal model to precisely characterize their relationships. Based on this formal model we then present F2F, a prototypical tool that predicts when a policy cannot be expressed in a given system. Our prototype gives detailed information about the unexpressible parts of a policy and provides administrators with hints for fixing the detected problems.","Ceragioli, Lorenzo;Degano, Pierpaolo;Galletta, Letterio",57205736407;7006345611;55260418300
10.1145/3477314.3507084,0,"Secure compilation investigates when compilation chains preserve security properties. Over the years, different formal criteria and proof techniques have been put forward for proving a compiler secure. However, these proposals require a lot of manual effort by compiler designers. This paper introduces a formal approach to mechanically support these efforts. We focus on the specific class of robust safety properties and we propose a translation validation approach that leverages program analysis techniques to check that a compilation run preserves security.","Busi, Matteo;Degano, Pierpaolo;Galletta, Letterio",57192711957;7006345611;55260418300
10.1109/CSF54842.2022.9919690,1,"Security Enhanced Linux (SELinux) is a security architecture for Linux implementing mandatory access control. It has been used in numerous security-critical contexts ranging from servers to mobile devices. But this is challenging as SELinux security policies are difficult to write, understand, and maintain. Recently, the intermediate language CIL was introduced to foster the development of high-level policy languages and to write structured configurations. However, CIL lacks mechanisms for ensuring that the resulting configurations obey desired information flow policies. To remedy this, we propose IFCIL, a backward compatible extension of CIL for specifying fine-grained information flow requirements for CIL configurations. Using IFCIL, administrators can express, e.g., confidentiality, integrity, and non-interference properties. We also provide a tool to statically verify these requirements.","Ceragioli, Lorenzo;Galletta, Letterio;Degano, Pierpaolo;Basin, David",57205736407;55260418300;7006345611;7003799223
10.1016/j.jpdc.2021.07.004,3,"The Internet of Things is deeply shaping our society and our lives. Smart devices automatically collect, aggregate and exchange data on our behalf and free us from the drudgery of doing it. These data are often crucial because critical decisions, such as controlling cyber-physical systems, are made depending on them or because they feed learning algorithms. Safety and security issues related to devices and to data can have a major impact on smart systems and can have serious consequences if they oversee essential services, such as delivering power, water, transport, and so on. For this reason, it is crucial to identify the most critical components in a network of devices and to evaluate how they are vulnerable to accidental or to intentional failures. We propose to use the process calculus IOT-LYSA to model systems and to apply a Control Flow Analysis to statically predict the manipulation of data, as well as on which data the critical decisions depend, in particular those affecting actuations. By exploiting suitable metrics, we can use the results of the analysis so as to provide system administrators with estimates of the safety and security of their systems.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.1016/j.scico.2021.102657,0,"The ever-growing size of programs and their continuous evolution require building fast and efficient analyzers. Here we focus on the static ones, in particular on type systems, for both checking and inference. Just as programs change by incrementally changing or inserting pieces of code, called diffs, also type systems should be incremental and re-type the diffs, only. An algorithmic schema is proposed that mechanically derives an incremental version of existing, standard typing algorithms. Ours is a grey-box approach: just the shape of the typing rules, that of the types and some domain-specific knowledge are needed to instantiate our schema. Here, we present the foundations of our approach and the conditions for its correctness. Our schema is applied to derive four incremental typing and inference algorithms for languages in different programming paradigms. We implemented an OCaml module that inputs a type system and outputs its incrementalized version. Experimental results show that our approach is effective, and prove its usage beneficial.","Busi, Matteo;Degano, Pierpaolo;Galletta, Letterio",57192711957;7006345611;55260418300
10.1145/3470534,3,"Computer systems often provide hardware support for isolation mechanisms such as privilege levels, virtual memory, or enclaved execution. Over the past years, several successful software-based side-channel attacks have been developed that break, or at least significantly weaken, the isolation that these mechanisms offer. Extending a processor with new architectural or micro-architectural features brings a risk of introducing new software-based side-channel attacks. This article studies the problem of extending a processor with new features without weakening the security of the isolation mechanisms that the processor offers. Our solution is heavily based on techniques from research on programming languages. More specifically, we propose to use the programming language concept of full abstraction as a general formal criterion for the security of a processor extension. We instantiate the proposed criterion to the concrete case of extending a microprocessor that supports enclaved execution with secure interruptibility. This is a very relevant instantiation, as several recent papers have shown that interruptibility of enclaves leads to a variety of software-based side-channel attacks. We propose a design for interruptible enclaves and prove that it satisfies our security criterion. We also implement the design on an open-source enclave-enabled microprocessor and evaluate the cost of our design in terms of performance and hardware size.","Busi, Matteo;Noorman, Job;Van Bulck, Jo;Galletta, Letterio;Degano, Pierpaolo;Mühlberg, Jan Tobias;Piessens, Frank",57192711957;55447479800;56912465500;55260418300;7006345611;23009453600;6602153049
10.1007/978-3-030-91631-2_7,1,"We address the problem of a mutual agreement between a bug bounty issuer and a bounty hunter in blockchain smart contracts. Our framework is VeriOSS, where a Proof of Knowledge protocol is used. Through it, the hunter communicates in clear increasingly large portions of the detected bug and gets back increasingly ample portions of the reward, provided that the issuer considers the received information plausible. The process is iterated until the entire bug is revealed and the entire reward given. We formalize this protocol using the Applied Pi-calculus and we apply ProVerif to it so as to verify its correctness, i.e., that only the relevant information and the corresponding reward are exchanged and that the integrity and the authenticity of the communications is granted.","Degano, Pierpaolo;Galletta, Letterio;Gerali, Selene",7006345611;55260418300;57350473400
10.1007/978-3-030-78089-0_10,0,"Service contracts characterise the desired behavioural compliance of a composition of services, typically defined by the fulfilment of all service requests through service offers. Contract automata are a formalism for specifying behavioural service contracts. Based on the notion of synthesis of the most permissive controller from Supervisory Control Theory, a safe orchestration of contract automata can be computed that refines a composition into a compliant one. This short paper summarises the contributions published in [8], where we endow contract automata with two orthogonal layers of variability: (i) at the structural level, constraints over service requests and offers define different configurations of a contract automaton, depending on which requests and offers are selected or discarded; and (ii) at the behavioural level, service requests of different levels of criticality can be declared, which induces the novel notion of semi-controllability. The synthesis of orchestrations is thus extended to respect both the structural and the behavioural variability constraints. Finally, we show how to efficiently compute the orchestration of all configurations from only a subset of these configurations. A recently redesigned and refactored tool supports the developed theory.","Basile, Davide;ter Beek, Maurice H.;Degano, Pierpaolo;Legay, Axel;Ferrari, Gian Luigi;Gnesi, Stefania;Di Giandomenico, Felicita",55960640200;8382048200;7006345611;56271160800;56221627000;6603718373;6701688160
10.3233/JCS-200017,6,"Firewalls are essential for managing and protecting computer networks. They permit specifying which packets are allowed to enter a network, and also how these packets are modified by IP address translation and port redirection. Configuring a firewall is notoriously hard, and one of the reasons is that it requires using low level, hard to interpret, configuration languages. Equally difficult are policy maintenance and refactoring, as well as porting a configuration from one firewall system to another. To address these issues we introduce a pipeline that assists system administrators in checking if: (i) the intended security policy is actually implemented by a configuration; (ii) two configurations are equivalent; (iii) updates have the desired effect on the firewall behavior; (iv) there are useless or redundant rules; additionally, an administrator can (v) transcompile a configuration into an equivalent one in a different language; and (vi) maintain a configuration using a generic, declarative language that can be compiled into different target languages. The pipeline is based on IFCL, an intermediate firewall language equipped with a formal semantics, and it is implemented in an open source tool called FWS. In particular, the first stage decompiles real firewall configurations for iptables, ipfw, pf and (a subset of) Cisco IOS into IFCL. The second one transforms an IFCL configuration into a logical predicate and uses the Z3 solver to synthesize an abstract specification that succinctly represents the firewall behavior. System administrators can use FWS to analyze the firewall by posing SQL-like queries, and update the configuration to meet the desired security requirements. Finally, the last stage allows for maintaining a configuration by acting directly on its abstract specification and then compiling it to the chosen target language. Tests on real firewall configurations show that FWS can be fruitfully used in real-world scenarios.","Bodei, Chiara;Ceragioli, Lorenzo;Degano, Pierpaolo;Focardi, Riccardo;Galletta, Letterio;Luccio, Flaminia;Tempesta, Mauro;Veronese, Lorenzo",6603107885;57205736407;7006345611;6701345241;55260418300;7005244352;56789732400;56344550600
10.1007/s10817-020-09568-7,0,"Verifying the correctness of a system as a whole requires establishing that it satisfies a global specification. When it does not, it would be helpful to determine which modules are incorrect. As a consequence, specification decomposition is a relevant problem from both a theoretical and practical point of view. Until now, specification decomposition has been independently addressed by the control theory and verification communities through natural projection and partial model checking, respectively. We prove that natural projection reduces to partial model checking and, when cast in a common setting, the two are equivalent. Apart from their foundational interest, our results build a bridge whereby the control theory community can reuse algorithms and results developed by the verification community. Furthermore, we extend the notions of natural projection and partial model checking from finite-state to symbolic transition systems and we show that the equivalence still holds. Symbolic transition systems are more expressive than traditional finite-state transition systems, as they can model large systems, whose behavior depends on the data handled, and not only on the control flow. Finally, we present an algorithm for the partial model checking of both kinds of systems that can be used as an alternative to natural projection.","Costa, Gabriele;Galletta, Letterio;Degano, Pierpaolo;Basin, David;Bodei, Chiara",32067717500;55260418300;7006345611;7003799223;6603107885
10.1109/CSF49147.2020.00026,20,"Computer systems often provide hardware support for isolation mechanisms like privilege levels, virtual memory, or enclaved execution. Over the past years, several successful software-based side-channel attacks have been developed that break, or at least significantly weaken the isolation that these mechanisms offer. Extending a processor with new architectural or micro-architectural features, brings a risk of introducing new such side-channel attacks. This paper studies the problem of extending a processor with new features without weakening the security of the isolation mechanisms that the processor offers. We propose to use full abstraction as a formal criterion for the security of a processor extension, and we instantiate that criterion to the concrete case of extending a microprocessor that supports enclaved execution with secure interruptibility of these enclaves. This is a very relevant instantiation as several recent papers have shown that interruptibility of enclaves leads to a variety of software-based side-channel attacks. We propose a design for interruptible enclaves, and prove that it satisfies our security criterion. We also implement the design on an open-source enclave-enabled microprocessor, and evaluate the cost of our design in terms of performance and hardware size.","Busi, Matteo;Noorman, Job;Bulck, Jo Van;Galletta, Letterio;Degano, Pierpaolo;Muhlberg, Jan Tobias;Piessens, Frank",57192711957;55447479800;57218850988;55260418300;7006345611;23009453600;6602153049
10.1016/j.scico.2019.102344,15,"Service contracts characterise the desired behavioural compliance of a composition of services. Compliance is typically defined by the fulfilment of all service requests through service offers, as dictated by a given Service-Level Agreement (SLA). Contract automata are a recently introduced formalism for specifying and composing service contracts. Based on the notion of synthesis of the most permissive controller from Supervisory Control Theory, a safe orchestration of contract automata can be computed that refines a composition into a compliant one. To model more fine-grained SLA and more adaptive service orchestrations, in this paper we endow contract automata with two orthogonal layers of variability: (i) at the structural level, constraints over service requests and offers define different configurations of a contract automaton, depending on which requests and offers are selected or discarded, and (ii) at the behavioural level, service requests of different levels of criticality can be declared, which induces the novel notion of semi-controllability. The synthesis of orchestrations is thus extended to respect both the structural and the behavioural variability constraints. Finally, we show how to efficiently compute the orchestration of all configurations from only a subset of these configurations. A prototypical tool supports the developed theory.","Basile, Davide;ter Beek, Maurice H.;Degano, Pierpaolo;Legay, Axel;Ferrari, Gian Luigi;Gnesi, Stefania;Di Giandomenico, Felicita",55960640200;8382048200;7006345611;56271160800;56221627000;6603718373;6701688160
,0,"In a collaborative distributed environment, users own a set of private resources that they possibly share with each other to achieve mutual advantages. The access to resources is regulated by a policy defined by each user in isolation, and independently of the others. However, typical access control languages allow defining policies that only check the roles or the attributes of the requesters and resources. But they do not impose a fair exchange of access grants by taking into account what requesters offer to others. Here, we present MuAC, a logic-based access control language designed for expressing mutuality. In particular, MuAC allows specifying conditions on what requesters must offer in exchange for using a particular resource.","Ceragioli, Lorenzo;Degano, Pierpaolo;Galletta, Letterio",57205736407;7006345611;55260418300
,0,"Obfuscating compilers protect a software by obscuring its meaning and impeding the reconstruction of its original source code. The typical concern when defining such compilers is their robustness against reverse engineering and the performance of the produced code. Little work has been done in studying whether the security properties of a program are preserved under obfuscation. In this paper we start addressing this problem: we consider control-flow flattening, a popular obfuscation technique used in industrial compilers, and a specific security policy, namely constant-time. We prove that this obfuscation preserves the policy, i.e., that every program satisfying the policy still does after the transformation.","Busi, Matteo;Degano, Pierpaolo;Galletta, Letterio",57192711957;7006345611;55260418300
10.1007/978-3-030-41103-9_9,4,"The Internet of Things (IoT) is deeply changing our society. Daily we use smart devices that automatically collect, aggregate and exchange data about our lives. These data are often pivotal when they are used e.g. to train learning algorithms, to control cyber-physical systems, and to guide administrators to take crucial decisions. As a consequence, security attacks on devices can cause severe damages on IoT systems that take care of essential services, such as delivering power, water, transport, and so on. The difficulty of preventing intrusions or attacks is magnified by the big amount of devices and components IoT systems are composed of. Therefore, it is crucial to identify the most critical components in a network of devices and to understand their level of vulnerability, so as to detect where it is better to intervene for improving security. In this paper, we start from the modelling language IoT-LySa and from the results of Control Flow Analysis that statically predict the manipulation of data and their possible trajectories. On this basis, we aim at deriving possible graphs of how data move and which are their dependencies. These graphs can be analysed, by exploiting some security metrics - among which those introduced by Barrere, Hankin et al. - offering system administrators different estimates of the security level of their systems.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.1007/s11227-018-2603-3,0,"In the times of mobility and pervasiveness of computing, contextual information plays an increasingly crucial role in applications. This kind of information becomes a first class citizen in context-oriented programming (COP) paradigm. COP languages provide primitive constructs for easily writing applications that adapt their behaviour depending on the evolution of their operational environment, namely the context. We present these new constructs, the issues and the challenges that arise, reporting on our recent work on MLCoDa. It is a declarative language specifically designed for adaptation and equipped with a clear formal semantics and analysis tools. We will discuss some experiments done with a preliminary implementation of MLCoDa. Through them we will show how applications and context interactions can be better specified, analysed and controlled.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.1145/3338504.3357340,2,"Firewalls are a fundamental tool for managing and protecting computer networks. They not only permit specifying which packets are allowed to enter a network, but also how these packets are modified by translating IP addresses and performing port redirection (NAT). Many firewalls systems are available which provide different tools and configuration languages. In contrast with the intuition, the most widespread languages cannot express the same configurations, even when simple filtering and NAT transformations are considered. This paper formally investigates the power of firewall languages of the most used tools in Unix and Linux. In particular, we introduce two kinds of expressivity. The first concerns the ways a packet can be transformed by NAT. According to this criterion iptables is strictly more expressive than ipfw and pf that are equivalent. The second kind is more finer-grained and considers the dependencies among the management of all packets. Our results show that some configurations are expressible in a system, but not in another one. Indeed, iptables is incomparable with the others, and ipfw is more expressive than pf.","Ceragioli, Lorenzo;Degano, Pierpaolo;Galletta, Letterio",57205736407;7006345611;55260418300
,0,"Security of software systems is of paramount importance, for both individuals, and the society and its infrastructures. The programs that support our activities must therefore be built robust against attackers. We will briefly survey the methods and the tools offered by programming languages to assist designers and programmers in implementing secure software components. We also discuss the main techniques for verifying the security properties of these components, especially when they are not developed from scratch.","Costa, Gabriele;Degano, Pierpaolo;Galletta, Letterio",32067717500;7006345611;55260418300
10.1007/978-3-030-31175-9_6,2,"Designing and maintaining firewall configurations is hard, also for expert system administrators. Indeed, policies are made of a large number of rules and are written in low-level configuration languages that are specific to the firewall system in use. As part of a larger group, we have addressed these issues and have proposed a semantic-based transcompilation pipeline. It is supported by FWS, a tool that analyses a real configuration and ports it from a firewall system to another. To our surprise, we discovered that some configurations expressed in a real firewall system cannot be ported to another system, preserving the semantics. Here we outline the main reasons for the detected differences between the firewall languages, and describe F2F, a tool that checks if a given configuration in a system can be ported to another system, and reports its user on which parts cause problems and why.","Ceragioli, Lorenzo;Degano, Pierpaolo;Galletta, Letterio",57205736407;7006345611;55260418300
10.1007/978-3-030-30985-5_9,0,"The rigorous design of Service-Oriented Computing (SOC) applications has been identified as one of the primary research challenges for the next 10 years. Many foundational theories for SOC have been defined, but they often rely on mechanisms different from real-world SOC technologies, hindering actual service modelling and verification. In this paper, we propose a novel automata-based formalism of service contracts equipped with a mechanism, inspired by current web service technologies, exploiting correlation data to drive service interactions and with formal foundations enabling reasoning about service correctness.","Basile, Davide;Pugliese, Rosario;Tiezzi, Francesco;Degano, Pierpaolo;Ferrari, Gian Luigi",55960640200;55909438000;23089657900;7006345611;56221627000
10.1007/978-3-030-19052-1_6,1,"Security of software systems has to be preserved while they grow and change incrementally. The problem is to make the analysis of their security properties adhere to such a development. In particular we concentrate here on static type systems. Given a non-incremental type system, the algorithm we propose permits using it incrementally, so avoiding to develop new incremental versions of it. As a proof-of-concept we show how our technique permits an incremental checking of non-interference with robust declassification, starting from the classical type system by Myers, Sabelfeld and Zdancewic.","Busi, Matteo;Degano, Pierpaolo;Galletta, Letterio",57192711957;7006345611;55260418300
10.1007/978-3-030-21485-2_24,3,"Klaim (Kernel Language for Agents Interaction and Mobility) has been devised to design distributed applications composed by many components deployed over the nodes of a distributed infrastructure and to offer programmers primitive constructs for communicating, distributing and retrieving data. Data could be sensitive and some nodes could not be secure. As a consequence it is important to track data in their traversal of the network. To this aim, we propose a Control Flow Analysis that over-approximates the behaviour of Klaim processes and tracks how tuple data can move in the network.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.1007/978-3-030-20652-9_7,5,"Modern languages are equipped with static type checking/inference that helps programmers to keep a clean programming style and to reduce errors. However, the ever-growing size of programs and their continuous evolution require building fast and efficient analysers. A promising solution is incrementality, aiming at only re-typing the diffs, i.e. those parts of the program that change or are inserted, rather than the entire codebase. We propose an algorithmic schema that drives an incremental usage of existing, standard typing algorithms with no changes. Ours is a grey-box approach: just the shape of the input, that of the results and some domain-specific knowledge are needed to instantiate our schema. Here, we present the foundations of our approach and the conditions for its correctness. We show it at work to derive two different incremental typing algorithms. The first type checks an imperative language to detect information flow and non-interference, and the second infers types for a functional language. We assessed our proposal on a prototypical implementation of an incremental type checker. Our experiments show that using the type checker incrementally is (almost) always rewarding.","Busi, Matteo;Degano, Pierpaolo;Galletta, Letterio",57192711957;7006345611;55260418300
,0,,"Degano, Pierpaolo;Zunino, Roberto",7006345611;8382815000
10.1109/EuroSP.2018.00015,20,"Configuring and maintaining a firewall configuration is notoriously hard. Policies are written in low-level, platform-specific languages where firewall rules are inspected and enforced along non trivial control flow paths. Further difficulties arise from Network Address Translation (NAT), since filters must be implemented with addresses translations in mind. In this work, we study the problem of decompiling a real firewall configuration into an abstract specification. This abstract version throws the low-level details away by exposing the meaning of the configuration, i.e., the allowed connections with possible address translations. The generated specification makes it easier for system administrators to check if: (i) the intended security policy is actually implemented; (ii) two configurations are equivalent; (iii) updates have the desired effect on the firewall behavior. The peculiarity of our approach is that is independent of the specific target firewall system and language. This independence is obtained through a generic intermediate language that provides the typical features of real configuration languages and that separates the specification of the rulesets, determining the destiny of packets, from the specification of the platform-dependent steps needed to elaborate packets. We present a tool that decompiles real firewall configurations from different systems into this intermediate language and uses the Z3 solver to synthesize the abstract specification that succinctly represents the firewall behavior and the NAT. Tests on real configurations show that the tool is effective: it synthesizes complex policies in a matter of minutes and, and it answers to specific queries in just a few seconds. The tool can also point out policy differences before and after configuration updates in a simple, tabular form.","Bodei, Chiara;Degano, Pierpaolo;Galletta, Letterio;Focardi, Riccardo;Tempesta, Mauro;Veronese, Lorenzo",6603107885;7006345611;55260418300;6701345241;56789732400;56344550600
10.1007/s11047-018-9673-2,12,"Systems biology is a research area devoted to developing computational frameworks for modeling biological systems in a holistic fashion. Within this approach, the typical advantages of using computer systems and formal methodologies are applicable. Experiments can indeed be carried on in silico that turn out to be much quicker and less expensive than wet-lab experiments. This paper surveys a specific computational approach to systems biology, based on the so-called process calculi, a formalism for describing concurrent systems. After a gentle, intuitive introduction to both fields, we present the most successful process calculi designed and used for this purpose. We start from a basic process calculus that is then extended with increasingly expressive features to better reflect the biological aspects of interest. We then compare the expressive power of the resulting calculi, mentioning if they are supported by software tools. From this comparison we derive some suggestions on the most suitable frameworks for dealing with specific cases of interest, with the help of three relevant case studies.","Bernini, Andrea;Brodo, Linda;Degano, Pierpaolo;Falaschi, Moreno;Hermith, Diana",7004103621;23395914900;7006345611;7004184628;50661302200
10.1007/978-3-319-89960-2_19,2,"Specification decomposition is a theoretically interesting and practically relevant problem for which two approaches were independently developed by the control theory and verification communities: natural projection and partial model checking. In this paper we show that, under reasonable assumptions, natural projection reduces to partial model checking and, when cast in a common setting, the two are equivalent. Aside from their theoretical interest, our results build a bridge whereby the control theory community can reuse algorithms and results developed by the verification community. In addition, we present an algorithm and a tool for the partial model checking of finite-state automata that can be used as an alternative to natural projection.","Costa, Gabriele;Basin, David;Bodei, Chiara;Degano, Pierpaolo;Galletta, Letterio",32067717500;7003799223;6603107885;7006345611;55260418300
10.1007/978-3-319-89722-6_13,11,"Porting a policy from a firewall system to another is a difficult and error prone task. Indeed, network administrators have to know in detail the policy meaning, as well as the internals of the firewall systems and of their languages. Equally difficult is policy maintenance and refactoring, e.g., removing useless or redundant rules. In this paper, we present a transcompiling pipeline that automatically tackles both problems: it can be used to port a policy into an equivalent one, when the target firewall language is different from the source one; when the two languages coincide, transcompiling supports policy maintenance and refactoring. Our transcompiler and its correctness are based on a formal intermediate firewall language that we endow with a formal semantics.","Bodei, Chiara;Degano, Pierpaolo;Focardi, Riccardo;Galletta, Letterio;Tempesta, Mauro",6603107885;7006345611;6701345241;55260418300;56789732400
10.2424/ASTSN.M.2018.6,4,"The adoption of precision agriculture has been enabled by the arrival of the new ICT technologies included in the wider context of the Internet of Things. We advocate that formal software engineering models and methodologies can provide support to the design of networks for precision agriculture. We propose here the process algebraic framework as a formal support for understanding the possible data-flows for decision-making, once identified from where data are to be gathered. In particular, we exploit IoT-LySa, a recently introduced process calculus, through which we model a possible agriculture scenario. We consider grape cultivation, with particular attention to a careful usage of water. The static analysis developed for IoT-LySa can be used for predicting the interactions among nodes, how data spread from sensors to the network, and how they are manipulated, so helping in water preservation.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
,2,"Firewalls are notoriously hard to configure and maintain. Policies are written in low-level, system-specific languages where rules are inspected and enforced along non-trivial control flow paths. Moreover, firewalls are tightly related to Network Address Translation (NAT) since filters need to be specified taking into account the possible translations of packet addresses, further complicating the task of network administrators. To simplify this job, we propose FIRE WALL SYNTHESIZER (FWS), a tool that decompiles real firewall configurations from different systems into an abstract specification. This representation highlights the meaning of a configuration, i.e., the allowed connections with possible address translations. We show the usage of FWS in analyzing and maintaining a configuration on a simple (yet realistic) scenario and we discuss how the tool scales on real-world policies.","Bodei, Chiara;Degano, Pierpaolo;Focardi, Riccardo;Galletta, Letterio;Tempesta, Mauro;Veronese, Lorenzo",6603107885;7006345611;6701345241;55260418300;56789732400;56344550600
10.4204/EPTCS.261.6,1,"The design of IoT systems could benefit from the combination of two different analyses. We perform a first analysis to approximate how data flow across the system components, while the second analysis checks their communication soundness. We show how the combination of these two analyses yields further benefits hardly achievable by separately using each of them. We exploit two independently developed tools for the analyses. Firstly, we specify IoT systems in IoT-LySa, a simple specification language featuring asynchronous multicast communication of tuples. The values carried by the tuples are drawn from a term-algebra obtained by a parametric signature. The analysis of communication soundness is supported by ChorGram, a tool developed to verify the compatibility of communicating finite-state machines. In order to combine the analyses we implement an encoding of IoT-LySa processes into communicating machines. This encoding is not completely straightforward because IoT-LySa has multicast communications with data, while communication machines are based on point-to-point communications where only finitely many symbols can be exchanged. To highlight the benefits of our approach we appeal to a simple yet illustrative example.","Bodei, Chiara;Degano, Pierpaolo;Galletta, Letterio;Tuosto, Emilio",6603107885;7006345611;55260418300;8967981400
,25,"The Internet of Things (IoT) offers the infrastructure of the information society. It hosts smart objects that automatically collect and exchange data of various kinds, directly gathered from sensors or generated by aggregations. Suitable coordination primitives and analysis mechanisms are in order to design and reason about IoT systems, and to intercept the implied technological shifts. We address some of these issues from a foundational point of view. To study them, we define IoT-LySa, a process calculus endowed with a static analysis that tracks the provenance and the manipulation of IoT data, and how they flow in the system. The results of the analysis can be used by a designer to check the behaviour of smart objects, in particular to verify non-functional properties, among which security.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.1007/s00236-016-0261-6,0,"Two kinds of automata are presented, for recognising new classes of regular and context-free nominal languages. We compare their expressive power with analogous proposals in the literature, showing that they express novel classes of languages. Although many properties of classical languages hold no longer in the nominal case, we design a slight restriction of our models that preserve some interesting ones. In particular, we prove the emptiness problem decidable and we construct the intersection between (restricted) regular and context-free automata. By examples and walking through their properties we argue the relevance of our models in the context of the verification of resource usage patterns.","Degano, Pierpaolo;Ferrari, Gian Luigi;Mezzetti, Gianluca",7006345611;56221627000;51161481600
10.1145/3023956.3023965,19,In Service Oriented Computing (SOC) contracts characterise the behavioural conformance of a composition of services and guarantee that the composition does not lead to spurious results. Variability features can enable services to adapt to customer requirements and to changes in the context in which they execute. We extend a recently introduced formal model of service contracts to specify variability mechanisms in a composition of services. Necessary and permitted service requests can be defined and triggered to increase adaptability. The compositional rules of the original formalism are enriched to fulfil all necessary requirements and the maximal number of permitted ones.,"Basile, Davide;Di Giandomenico, Felicita;Gnesi, Stefania;Degano, Pierpaolo;Ferrari, Gian Luigi",55960640200;6701688160;6603718373;7006345611;56221627000
10.1007/978-3-319-62932-2_1,1,"Contextual information plays an increasingly crucial role in concurrent applications in the times of mobility and pervasiveness of computing. Context-Oriented Programming languages explicitly treat this kind of information. They provide primitive constructs to adapt the behaviour of a program, depending on the evolution of its operational environment, which is affected by other programs hosted therein independently and unpredictably. We discuss these issues and the challenges they pose, reporting on our recent work on ML CoDa, a language specifically designed for adaptation and equipped with a clear formal semantics and analysis tools. We will show how applications and context interactions can be better specified, analysed and controlled, with the help of some experiments done with a preliminary implementation of ML CoDa.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.2168/LMCS-12(4:6)2016,22,"An approach to the formal description of service contracts is presented in terms of automata. We focus on the basic property of guaranteeing that in the multi-party composition of principals each of them gets his requests satisfied, so that the overall composition reaches its goal. Depending on whether requests are satisfied synchronously or asynchronously, we construct an orchestrator that at static time either yields composed services enjoying the required properties or detects the principals responsible for possible violations. To do that in the asynchronous case we resort to Linear Programming techniques. We also relate our automata with two logically based methods for specifying contracts.","Basile, Davide;Degano, Pierpaolo;Ferrari, Gian Luigi",55960640200;7006345611;56221627000
10.4204/EPTCS.223.9,12,"The Internet of Things (IoT) is smartifying our everyday life. Our starting point is IOT-LYSA, a calculus for describing IoT systems, and its static analysis, which will be presented at Coordination 2016. We extend the mentioned proposal in order to begin an investigation about security issues, in particular for the static verification of secrecy and some other security properties.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.4204/EPTCS.211.4,3,"Context-Oriented Programming languages provide us with primitive constructs to adapt program behaviour depending on the evolution of their operational environment, namely the context. In previous work we proposed MLCoDa, a context-oriented language with two-components: a declarative constituent for programming the context and a functional one for computing. This paper describes an extension of MLCoDa to deal with adaptation to unpredictable context changes notified by asynchronous events.","Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",7006345611;56221627000;55260418300
10.1109/TSE.2015.2496941,12,"Adaptive systems are designed to modify their behaviour in response to changes of their operational environment. We propose a two-component language for adaptive programming, within the Context-Oriented Programming paradigm. It has a declarative constituent for programming the context and a functional one for computing. We equip our language with a dynamic formal semantics. Since wrong adaptation could severely compromise the correct behaviour of applications and violate their properties, we also introduce a two-phase verification mechanism. It is based on a type and effect system that type-checks programs and computes, as an effect, a sound approximation of their behaviour. The effect is exploited at load time to mechanically verify that programs correctly adapt themselves to all possible running environments.","Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",7006345611;56221627000;55260418300
10.1016/j.jlamp.2015.09.011,23,"We investigate the relations between two automata-based models for describing and studying distributed services, called contract automata and communicating machines. In the first model, distributed services are abstracted away as automata – oblivious of their partners – that coordinate with each other through an orchestrator. The second one is concerned with the interactions occurring between distributed services, that are represented by channel-based asynchronous communications; then services are coordinated through choreography. We define a notion of strong agreement on contract automata; exhibit a natural mapping from this model to communicating machines with a synchronous semantics; and give conditions to ensure that strong agreement corresponds to well-formed choreography. Then these results are extended to a more liberal notion of agreement and to a fully asynchronous semantics of communicating machines.","Basile, D.;Degano, P.;Ferrari, G. L.;Tuosto, E.",55960640200;7006345611;56221627000;8967981400
,2,"A concurrent extension of the recent COP language MLCoDa is presented. We formalise its operational semantics and we propose a run time verification mechanism that enforces a notion of non-interference among concurrent threads. More precisely, this mechanism prevents an application from modifying the context so as to dispose some resources or to contradict assumptions upon which other applications rely.","Busi, Matteo;Degano, Pierpaolo;Galletta, Letterio",57192711957;7006345611;55260418300
10.3233/JCS-160551,8,"Adaptive systems improve their efficiency by modifying their behaviour to respond to changes in their operational environment. Also, security must adapt to these changes and policy enforcement becomes dependent on the dynamic contexts. We study these issues within MLCoDa, (the core of) an adaptive declarative language proposed recently. A main characteristic of MLCoDa is to have two components: a logical one for handling the context and a functional one for computing. We extend this language with security policies that are expressed in logical terms. They are of two different kinds: context and application policies. The first, unknown a priori to an application, protect the context from unwanted changes. The others protect the applications from malicious actions of the context, can be nested and can be activated and deactivated according to their scope. An execution step can only occur if all the policies in force hold, under the control of an execution monitor. Beneficial to this is a type and effect system, which safely approximates the behaviour of an application, and a further static analysis, based on the computed effect. The last analysis can only be carried on at load time, when the execution context is known, and it enables us to efficiently enforce the security policies on the code execution, by instrumenting applications. The monitor is thus implemented within MLCoDa, and it is only activated on those policies that may be infringed, and switched off otherwise.","Bodei, Chiara;Degano, Pierpaolo;Galletta, Letterio;Salvatori, Francesco",6603107885;7006345611;55260418300;56711721400
10.1007/978-3-319-39519-7_3,21,"The Internet of Things (IoT) is here: smart objects are pervading our everyday life. Smart devices automatically collect and exchange data of various kinds, directly gathered from sensors or generated by aggregations. Suitable coordination primitives and analysis mechanisms are in order to design and reason about IoT systems, and to intercept the implied technology shifts. We address these issues by defining IoT-LySa, a process calculus endowed with a static analysis that tracks the provenance and the route of IoT data, and detects how they affect the behaviour of smart objects.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.1007/978-3-319-39570-8_5,14,"We describe CAT, a toolkit supporting the analysis of communication-centric applications, i.e., applications consisting of ensembles of interacting services. Services are modelled in CAT as contract automata and communication safety is defined in terms of agreement properties. With the help of a simple (albeit non trivial) example, we demonstrate how CAT can (i) verify agreement properties, (ii) synthesise an orchestrator enforcing communication safety, (iii) detect misbehaving services, and (iv) check when the services form a choreography. The use of mixed-integer linear programming is a distinguished characteristic of CAT that allows us to verify context-sensitive properties of agreement.","Basile, Davide;Degano, Pierpaolo;Ferrari, Gian Luigi;Tuosto, Emilio",55960640200;7006345611;56221627000;8967981400
10.1007/978-3-319-27810-0_2,2,"We extend an existing two-phase static analysis for an adaptive programming language to also deal with dynamic resources. The focus of our analysis is on predicting how these are used, in spite of the different, ever changing operating environments to which applications automatically adapt their behaviour. Our approach is based on a type and effect system at compile time, followed by a control flow analysis carried on at loading time. Remarkably, the second analysis cannot be anticipated, because information about availability, implementation and other aspects of resources are unknown until the application is injected in the current environment.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",6603107885;7006345611;56221627000;55260418300
10.4204/EPTCS.201.2,6,"Context-Oriented programming languages provide us with primitive constructs to adapt program behaviour depending on the evolution of their operational environment, namely the context. In previous work we proposed MLcoDa, a context-oriented language with two-components: a declarative constituent for programming the context and a functional one for computing. This paper describes the implementation of MLcoDa as an extension of F#.","Canciani, Andrea;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",56789967500;7006345611;56221627000;55260418300
10.3233/JCS-150528,20,"Differential privacy aims at protecting the privacy of participants in statistical databases. Roughly, a mechanism satisfies differential privacy if the presence or value of a single individual in the database does not significantly change the likelihood of obtaining a certain answer to any statistical query posed by a data analyst. Differentially-private mechanisms are often oblivious: first the query is processed on the database to produce a true answer, and then this answer is adequately randomized before being reported to the data analyst. Ideally, a mechanism should minimize leakage - i.e., obfuscate as much as possible the link between reported answers and individuals' data - while maximizing utility - i.e., report answers as similar as possible to the true ones. These two goals, however, are in conflict with each other, thus imposing a trade-off between privacy and utility. In this paper we use quantitative information flow principles to analyze leakage and utility in oblivious differentially-private mechanisms. We introduce a technique that exploits graph symmetries of the adjacency relation on databases to derive bounds on the min-entropy leakage of the mechanism.We consider a notion of utility based on identity gain functions, which is closely related to min-entropy leakage, and we derive bounds for it. Finally, given some graph symmetries, we provide a mechanism that maximizes utility while preserving the required level of differential privacy.","Alvim, Mrio S.;Andrés, Miguel E.;Chatzikokolakis, Konstantinos;Degano, Pierpaolo;Palamidessi, Catuscia",36623278200;24467665600;13104789600;7006345611;8965157200
10.1017/S096012951200093X,12,"We study usage automata, a formal model for specifying policies on the usage of resources. Usage automata extend finite state automata with some additional features, parameters and guards, that improve their expressivity. We show that usage automata are expressive enough to model policies of real-world applications. We discuss their expressive power, and we prove that the problem of telling whether a computation complies with a usage policy is decidable. The main contribution of this paper is a model checking technique for usage automata. The model is that of usages, i.e. basic processes that describe the possible patterns of resource access and creation. In spite of the model having infinite states, because of recursion and resource creation, we devise a polynomial-time model checking technique for deciding when a usage complies with a usage policy.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
10.1007/978-3-319-23165-5_6,1,"Exchanging resources often involves situations where a participant gives a resource without obtaining immediately the expected reward. For instance, one can buy an item without paying it in advance, but contracting a debt which must be eventually honoured. Resources, credits and debits can be represented, either implicitly or explicitly, in several formal models, among which Petri nets and linear logic. In this paper we study the relations between two of these models, namely intuitionistic linear logic with mix and Debit Petri nets. In particular, we establish a natural correspondence between provability in the logic, and marking reachability in nets.","Bartoletti, Massimo;Degano, Pierpaolo;Di Giamberardino, Paolo;Zunino, Roberto",9536042900;7006345611;57201842975;8382815000
10.4204/EPTCS.166.8,9,"We study the relations between a contract automata and an interaction model. In the former model, distributed services are abstracted away as automata - oblivious of their partners - that coordinate with each other through an orchestrator. The interaction model relies on channel-based asynchronous communication and choreography to coordinate distributed services. We define a notion of strong agreement on the contract model, exhibit a natural mapping from the contract model to the interaction model, and give conditions to ensure that strong agreement corresponds to well-formed choreography.","Basile, Davide;Degano, Pierpaolo;Ferrari, Gian Luigi;Tuosto, Emilio",55960640200;7006345611;56221627000;8967981400
10.1007/978-3-662-45917-1_3,12,"A novel approach to the formal description of service contracts is presented in terms of automata.We focus on the basic property of guaranteeing that in the multi-party composition of principals each individual gets his requests satisfied, so that the overall composition reaches its goal. Depending on whether requests are satisfied synchronously or asynchronously, we construct an orchestrator that at static time either yields composed services enjoying the required properties or detects the individuals responsible for possible violations. To do that in the asynchronous case we resort to techniques from Operational Research.","Basile, Davide;Degano, Pierpaolo;Ferrari, Gian Luigi",55960640200;7006345611;56221627000
10.1007/978-3-319-10882-7_5,9,"Adaptive systems improve their efficiency, by modifying their behaviour to respond to changes in their operational environment. Also, security must adapt to these changes and policy enforcement becomes dependent on the dynamic contexts. We extend (the core of) an adaptive functional language with primitives to enforce security policies on the code execution, and we exploit a static analysis to instrument programs. The introduced checks guarantee that no violation of the required security policies occurs.","Bodei, Chiara;Degano, Pierpaolo;Galletta, Letterio;Salvatori, Francesco",6603107885;7006345611;55260418300;56711721400
10.3233/FI-2014-1100,0,,"Degano, Pierpaolo;Karhumäki, Juhani;Massazza, Paolo",7006345611;26643465900;8908959900
10.1007/978-3-319-10431-7_28,9,"Adaptive systems are designed to modify their behaviour in response to changes of their operational environment. We adopt a language-based approach to the development of such systems, with particular attention to preventing them from failures in adaptation. The kernel of our proposal is a simple core language, equipped with a type and effect system that computes a sound approximation of program behaviour. The effect is exploited at loading time to verify that programs correctly adapt themselves to all possible running environments. © 2014 Springer International Publishing.","Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",7006345611;56221627000;55260418300
10.1145/2637066.2637072,9,"Adaptive applications are designed and programmed to dynamically adjust their behaviour to respond to changes of their execution environment. This paper introducesMLCoDa, a new COP language, made of two components: a declarative one for the context and a functional constituent for computing. Here we concentrate on the rational behind the design of MLCoDa and on its dynamic semantics. We also sketch a verification mechanism based on static analysis to prevent wrong adaptations which could compromise the correct behaviour of applications.","Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio",7006345611;56221627000;55260418300
10.1007/s11227-014-1211-0,6,"Internet is offering a variety of services that are assembled to accomplish requests made by clients. While serving a request, security of the communications and of the data exchanged among services is crucial. Since communications occur along specific channels, it is equally important to guarantee that the interactions between a client and a server never get blocked because either cannot access a selected channel. We address here both these problems, from a formal point of view. A static analysis is presented, guaranteeing that a composition of a client and of possibly nested services respects both security policies for access control, and compliance between clients and servers. © 2014 Springer Science+Business Media New York.","Basile, Davide;Degano, Pierpaolo;Ferrari, Gian Luigi",55960640200;7006345611;56221627000
10.3233/JCS-130488,0,,"Degano, Pierpaolo;Guttman, Joshua D.",7006345611;7004426173
10.1007/978-3-642-39274-0_11,1,"Two kinds of automata are introduced, for recognising regular and context-free nominal languages. We compare their expressive power with that of analogous proposals in the literature. Some properties of our languages are proved, in particular that emptiness of a context-free nominal language L is decidable, and that the intersection of L with a regular nominal language is still context-free. This paves the way for model-checking systems against access control properties in the nominal case, which is our main objective. © 2013 Springer-Verlag.","Degano, Pierpaolo;Ferrari, Gian Luigi;Mezzetti, Gianluca",7006345611;56221627000;51161481600
10.4204/EPTCS.109.5,3,"Context Oriented Programming (COP) concerns the ability of programs to adapt to changes in their running environment. A number of programming languages endowed with COP constructs and features have been developed. However, some foundational issues remain unclear. This paper proposes adopting static analysis techniques to reason on and predict how programs adapt their behaviour. We introduce a core functional language, ContextML, equipped with COP primitives for manipulating contexts and for programming behavioural variations. In particular, we specify the dispatching mechanism, used to select the program fragments to be executed in the current active context. Besides the dynamic semantics we present an annotated type system. It guarantees that the well-typed programs adapt to any context, i.e. the dispatching mechanism always succeeds at run-time.","Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio;Mezzetti, Gianluca",7006345611;56221627000;55260418300;51161481600
10.1007/978-3-642-39958-9_15,2,"Internet is offering a variety of services, that are assembled to accomplish requests made by clients. While serving a request, security of the communications and of the data exchanged among services is crucial. Furthermore, communications occur along specific channels, and it is equally important to guarantee that the interactions between a client and a server never get blocked because either cannot access a selected channel. We address here both these problems, from a formal point of view. A static analysis is presented, guaranteeing that a composition of a client and of possibly nested services respects both security policies for access control, and compliance between clients and servers. © 2013 Springer-Verlag Berlin Heidelberg.","Basile, Davide;Degano, Pierpaolo;Ferrari, Gian Luigi",55960640200;7006345611;56221627000
10.1007/978-3-642-31606-7_11,11,"Two classes of nominal automata, namely Usage Automata (UAs) and Variable Finite Automata (VFAs) are considered to express resource control policies over program execution traces expressed by a nominal calculus (Usages). We first analyse closure properties of UAs, and then show UAs less expressive than VFAs. We finally carry over to VFAs the symbolic technique for model checking Usages against UAs, so making it possible to verify the compliance of a program with a larger class of security properties. © 2012 Springer-Verlag.","Degano, Pierpaolo;Ferrari, Gian Luigi;Mezzetti, Gianluca",7006345611;56221627000;51161481600
10.1007/978-3-642-29420-4_3,62,"Differential privacy is a notion of privacy that has become very popular in the database community. Roughly, the idea is that a randomized query mechanism provides sufficient privacy protection if the ratio between the probabilities that two adjacent datasets give the same answer is bound by e ε. In the field of information flow there is a similar concern for controlling information leakage, i.e. limiting the possibility of inferring the secret information from the observables. In recent years, researchers have proposed to quantify the leakage in terms of min-entropy leakage, a concept strictly related to the Bayes risk. In this paper, we show how to model the query system in terms of an information-theoretic channel, and we compare the notion of differential privacy with that of min-entropy leakage. We show that differential privacy implies a bound on the min-entropy leakage, but not vice-versa. Furthermore, we show that our bound is tight. Then, we consider the utility of the randomization mechanism, which represents how close the randomized answers are to the real ones, in average. We show that the notion of differential privacy implies a bound on utility, also tight, and we propose a method that under certain conditions builds an optimal randomization mechanism, i.e. a mechanism which provides the best utility while guaranteeing ε-differential privacy. © 2012 Springer-Verlag.","Alvim, Mário S.;Andrés, Miguel E.;Chatzikokolakis, Konstantinos;Degano, Pierpaolo;Palamidessi, Catuscia",36623278200;24467665600;13104789600;7006345611;8965157200
10.1007/978-3-642-30829-1_18,13,"Context-Oriented programming languages provide us with primitive constructs to adapt program behaviour depending on the evolution of their operational environment. We are interested here in software components, the behaviour of which depend on the following: their actual operating context; the security policies that control accesses to their resources and the potential interactions with the external environment. For that, we extend a core functional language with mechanisms to program behavioural variations, to manipulate resources and to enforce security policies over both variations and resource usages. Additionally, there are message passing primitives to interact with the environment, also subject to a simple policy. Changes of the operational context are triggered both by the program and by the exchanged messages. Besides a definition of the dynamic semantics, we introduce a static analysis for guaranteeing programs to safely operate in any admissible context, and to correctly interact with the environment they comply with. © 2012 IFIP International Federation for Information Processing.","Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio;Mezzetti, Gianluca",7006345611;56221627000;55260418300;51161481600
10.3233/JCS-2011-0430,3,"Service Oriented Computing (SOC) is a programming paradigm aiming at characterising Service Networks. Services are entities waiting for requests from clients and they often result from the composition of many (sub-)services. We address here the problem of statically guaranteeing security of open services, i.e., services with unknown components. Security constraints are expressed by policies that service components must obey. We present here a type and effect system that safely over-approximates the possible run-time behaviour of open services, collecting partial information on the behaviour of their components. From such an approximation, we then extract a (partial) plan that drives executions of an open system that raises no security violations when plugged in any context. © 2012 - IOS Press and the authors. All rights reserved.","Costa, Gabriele;Degano, Pierpaolo;Martinelli, Fabio",32067717500;7006345611;7006394072
,0,,"Degano, Pierpaolo;Guttman, Joshua",7006345611;7004426173
10.1007/978-3-540-92910-9_55,3,"Knowledge about life processes develops through the interplay of theoretical speculation and experimental investigation. Both speculation and experiments present several difficulties that call for the development of faithful and accessible abstract models of the phenomena investigated. Several theories and techniques born in computer science have been proposed for the development of models that rely on solid formal bases and allow virtual experiments to be carried out computationally in silico. This chapter surveys the basics of process calculi and their applications to the modeling of biological phenomena at a system level. Process calculi were born within the theory of concurrency for describing and proving properties of distributed interacting systems. Their application to biological phenomena relies on an interpretation of systems as made of interacting components exhibiting a computational kind of behavior, ""cells as computation."" The first seminal proposals and the subsequent enhancements for best adapting computer science theories to the domain of biology (with particular reference to chemical, biochemical, and cellular phenomena) are surveyed.","Degano, Pierpaolo;Bracciali, Andrea",7006345611;8922231000
,0,,"Degano, Pierpaolo;Guttman, Joshua",7006345611;7004426173
,0,,"Degano, Pierpaolo;Guttman, Joshua D.",7006345611;7004426173
10.1007/978-3-642-33260-9_1,6,"We survey some critical issues arising in the ubiquitous computing paradigm, in particular the interplay between context-awareness and security. We then overview a language-based approach that addresses these problems from the point of view of Formal Methods. More precisely, we briefly describe a core functional language extended with mechanisms to express adaptation to context changes, to manipulate resources and to enforce security policies. In addition, we shall outline a static analysis for guaranteeing programs to securely behave in the digital environment they are part of. © 2012 IFIP International Federation for Information Processing.","Bodei, Chiara;Degano, Pierpaolo;Ferrari, Gian Luigi;Galletta, Letterio;Mezzetti, Gianluca",6603107885;7006345611;56221627000;55260418300;51161481600
10.1007/978-3-642-20401-2_11,3,"We present a framework for designing and composing services in a ""call-by-contract"" fashion, i.e. according to their behavior. We discuss how to correctly plan service compositions in some relevant classes of services and behavioral properties. To this aim, we propose both a core functional calculus for services, and a graphical design language. The core calculus features primitives for selecting and invoking services that respect given behavioral requirements, typically safety properties on the service execution history. A type and effect system over-approximates the actual run-time behavior of services. A further static analysis step finds the viable plans that drive the selection of those services matching the behavioral requirements on demand. © 2011 Springer-Verlag Berlin Heidelberg.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
10.1007/978-3-642-23178-0_3,7,"We introduce a formal framework to specify and enforce quantitative security policies. The framework consists of: (i) a stochastic process calculus to express the measurable space of computations in terms of Continuous Time Markov Chains; (ii) a stochastic modal logic (a variant of CSL) to represent the bound constraints on execution speed; (iii) two enforcement mechanisms of our quantitative security policies: potential and actual. The potential enforcement computes the probability of policy violations, thus providing a sort of static evaluation of when the policy is obeyed. This supports the user to accept/discard a component when the probability of the security violation is below/above a suitable chosen threshold. The actual enforcement computes at run-time the deviation of the execution speed from the acceptable rate. This specifies the execution monitor and drives it to abort unsafe executions. © 2011 Springer-Verlag Berlin Heidelberg.","Degano, Pierpaolo;Ferrari, Gian Luigi;Mezzetti, Gianluca",7006345611;56221627000;51161481600
,0,,"Bencivelli, Silvia;Degano, Pierpaolo",54381342200;7006345611
10.1016/j.tcs.2011.01.022,0,,"Degano, Pierpaolo",7006345611
,0,,"Degano, Pierpaolo;Etalle, Sandro;Guttman, Joshua",7006345611;6603762835;7004426173
10.1016/j.sysarc.2010.09.001,3,"Service Oriented Computing is a paradigm for creating a fully compositional service infrastructure. Compositionality makes security issues difficult to establish. As a matter of fact, defining global security properties on distribute, large-scale network seems to have little or even no sense at all. In a recent proposal, every single service specify its ad hoc security policies that are applied to (parts of) programs or services. These are called local policies and are amenable for developers. They are specified using a simple automaton-like structure, they offer full compositionality (through scope nesting) and a direct enforcing through a corresponding execution monitor. Compliance w.r.t. local policies is statically verified against a superset of the possible program execution traces, namely a history expression. History expressions for services are obtained through a type and effect system and then model checked for validity. A valid history expression only contains traces that never rise policy exceptions. Such history expressions drive the synthesis of composition plans, i.e. safe service orchestration. In this paper this approach is extended to work also on open networks, i.e. networks that are only partially specified. This allows one to compose services in a bottom-up fashion, while guaranteeing their correctness by construction. The potential, practical impact of our proposal is shown by applying it to a well known case study. © 2010 Elsevier B.V. All rights reserved.","Costa, Gabriele;Degano, Pierpaolo;Martinelli, Fabio",32067717500;7006345611;7006394072
10.1007/978-3-642-16074-5_4,2,"Service Oriented Computing (SOC) is a programming paradigm aiming at characterising Service Networks. Services are entities waiting for clients requests and they often result from the composition of many services. We address here the problem of statically guaranteeing security of open services, i.e. services with unknown components. Security constraints are expressed by local policies that service components must obey. We present here a type and effect system that safely over-approximates, in the form of history expressions, the possible run-time behaviour of open services, collecting partial information on the behaviours of their components. From a history expression, we then extract a plan that drives executions that never rise security violations. Finally, we show how partial plans satisfying security requirements can be put together to obtain a safe orchestration plan. © 2010 Springer-Verlag.","Costa, Gabriele;Degano, Pierpaolo;Martinelli, Fabio",32067717500;7006345611;7006394072
,0,,"Degano, Pierpaolo;Guttman, Joshua",7006345611;7004426173
10.3233/JCS-2010-0361,10,"A type flaw attack on a security protocol is an attack where an honest principal is cheated on interpreting a field in a message as the one with a type other than the intended one. In this paper, we shall present an extension of the LYSA calculus to cope with types, by using tags to represent the intended types of terms. We develop a Control Flow Analysis for this calculus which soundly over-approximates all the possible behaviour of a protocol and, in particular, is able to capture any type confusion that may occur during the protocol execution. The analysis acts in a descriptive way: it describes which violations may occur. In the same setting, our approach also offers a prescriptive usage: we can impose a type discipline, by forcing some data to be of the expected types. At this point, the analysis may statically check that type violations are not possible any longer. In other words, we instrument the code with the only checks necessary to enforce type security. Finally, we apply our framework to a multi-protocol setting, where the risk of having type flaw attacks is higher. Our analysis has been implemented and successfully applied to a number of security protocols, showing it is able to capture type flaw attacks. The implementation complexity of the analysis is low polynomial. © 2010 - IOS Press and the authors. All rights reserved.","Bodei, Chiara;Brodo, Linda;Degano, Pierpaolo;Gao, Han",6603107885;23395914900;7006345611;22941011100
10.1109/SEEFM.2009.13,2,"Local policies represent security properties that are applied to (parts of) programs or services. They are amenable for developers since they provide for a full compositionality (through scope nesting), for a simple, automaton-like structure and for a direct enforcing through a corresponding execution monitor. Compliance w.r.t. local policies is statically verified against a safe over-approximation of all the possible execution traces, namely a history expression. Given a service, a safe type and effect system extracts a history expression, from which a viable composition plan can be automatically produced. Viable plans drive executions that never rise policy exceptions. Our main contribution consists in defining a type and effect system that also deals with open systems. We extend the syntax of a service-oriented version of the λ- calculus, namely λreq, with resources and external branching operators. Then, we safely over-approximate the possible run-time behaviour of services collecting partial information on the relationship between the program flow and the actual resources. Indeed, the history expressions obtained in this way are compact, rather accurate and able to derive viable plans in most cases. © 2009 IEEE.","Costa, Gabriele;Degano, Pierpaolo;Martinelli, Fabio",32067717500;7006345611;7006394072
10.3233/JCS-2009-0357,30,"A static approach is proposed to study secure composition of services. We extend the λ-calculus with primitives for selecting and invoking services that respect given security requirements. Security-critical code is enclosed in policy framings with a possibly nested, local scope. Policy framings enforce safety and liveness properties. The actual run-time behaviour of services is over-approximated by a type and effect system. Types are standard, and effects include the actions with possible security concerns - as well as information about which services may be invoked at run-time. An approximation is model checked to verify policy framings within their scopes. This allows for removing any run-time execution monitor, and for determining the plans driving the selection of those services that match the security requirements on demand. © 2009 - IOS Press and the authors. All rights reserved.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.1007/978-3-642-03466-4_5,1,"We define a type and effect system for a λ-calculus extended with side effects, in the form of primitives for creating and accessing resources. The analysis correctly over-approximates the sequences of resource accesses performed by a program at run-time. To accurately analyse the binding between the creation of a resource and its accesses, our system exploits a new class of types. Our ν-types have the form νN. τ̇τ &rtri H, where the names in N are bound both in the type τ and in the effect H, that represents the sequences of resource accesses. © 2009 Springer Berlin Heidelberg.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
,0,,"Degano, Pierpaolo;Gorrieri, Roberto",7006345611;7003394376
,0,,"Degano, Pierpaolo;Viganò, Luca",7006345611;57208733404
10.1145/1552309.1552313,34,"An extension of the -calculus is proposed, to study resource usage analysis and verification. It features usage policies with a possibly nested, local scope, and dynamic creation of resources. We define a type and effect system that, given a program, extracts a history expression, that is, a sound overapproximation to the set of histories obtainable at runtime. After a suitable transformation, history expressions are model-checked for validity. A program is resource-safe if its history expression is verified valid: If such, no runtime monitor is needed to safely drive its executions. © 2009 ACM.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
,0,,"Degano, Pierpaolo;Guttman, Joshua;Martinelli, Fabio",7006345611;7004426173;7006394072
10.1007/978-3-642-00945-7_2,17,"We propose a model for specifying, analysing and enforcing safe usage of resources. Our usage policies allow for parametricity over resources, and they can be enforced through finite state automata. The patterns of resource access and creation are described through a basic calculus of usages. In spite of the augmented flexibility given by resource creation and by policy parametrization, we devise an efficient (polynomial-time) model-checking technique for deciding when a usage is resource-safe, i.e. when it complies with all the relevant usage policies. © Springer-Verlag Berlin Heidelberg 2009.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
10.1016/j.entcs.2009.06.013,2,"We introduce weak binders, a lightweight construct to deal with fresh names in nominal calculi. Weak binders do not define the scope of names as precisely as the standard ν-binders, yet they enjoy strong semantic properties. We provide them with a denotational semantics, an equational theory, and a trace inclusion preorder. Furthermore, we present a trace-preserving mapping between weak binders and ν-binders. © 2009 Elsevier B.V. All rights reserved.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
10.1007/978-3-540-88869-7_18,0,"We survey some recent work on the behavior of the calyx of Held synapse. The analysis considered are based on formal and quantitative models aimed at capturing emerging properties about signal transmission and plasticity phenomena. While surveying work about a specific and real-scale biological system, we distinguish between deterministic and stochastic approaches. We elaborate on the fact that in some cases, as in the calyx, the latter ones seem to be more adequate. The stochastic models, which we have developed, are based on a computational interpretation of biological systems. We illustrate the advantages of this approach in terms of expressiveness.","Bracciali, Andrea;Brunelli, Marcello;Cataldo, Enrico;Degano, Pierpaolo",8922231000;7005156454;23391832900;7006345611
,0,,"Degano, Pierpaolo;Gorrieri, Roberto",7006345611;7003394376
10.5381/jot.2009.8.4.a1,17,"We propose an extension to the security model of Java, that allows for specifying, analysing and enforcing history-based usage policies. Policies are dened by usage automata, that recognize the forbidden execution histories. Programmers can sandbox an untrusted piece of code with a policy, which is enforced at run-time through its local scope. A static analysis allows for optimizing the execution monitor: only the policies not guaranteed to be always obeyed will be enforced at run-time. ©JOT, 2009.","Bartoletti, Massimo;Costa, Gabriele;Degano, Pierpaolo;Martinelli, Fabio;Zunino, Roberto",9536042900;32067717500;7006345611;7006394072;8382815000
10.1016/j.tcs.2008.07.008,6,"We present a stochastic model of the presynaptic terminal in the calyx of Held synapse. This model exploits process calculi as a representation language and has a direct computational implementation that supports quantitative simulation trials of the behaviour of the synapse. To our knowledge, it represents the first model of synaptic activity based on process calculi. The model builds upon available data, the fitting of some parameters and developed working hypotheses. Experiments about plasticity have been carried out regarding synaptic facilitation and potentiation. Also, synaptic depression has been considered in a model exhibiting dynamical equilibrium. Overall, the simulation results are coherent with the experimental findings appearing in the literature about the modeled reality. These results represent a quite detailed description of the presynaptic activity. This multidisciplinary work validates some aspects of the approach based on process calculi with respect to the new application domain, such as abstraction, expressiveness and compositionality. © 2008 Elsevier B.V. All rights reserved.","Bracciali, Andrea;Brunelli, Marcello;Cataldo, Enrico;Degano, Pierpaolo",8922231000;7005156454;23391832900;7006345611
10.1007/978-3-540-79980-1_14,15,"A simple type confusion attack occurs in a security protocol, when a principal interprets data of one type as data of another. These attacks can be successfully prevented by ""tagging"" types of each field of a message. Complex type confusions occur instead when tags can be confused with data and when fields or sub-segments of fields may be confused with concatenations of fields of other types. Capturing these kinds of confusions is not easy in a process calculus setting, where it is generally assumed that messages are correctly interpreted. In this paper, we model in the process calculus LySa only the misinterpretation due to the confusion of a concatenation of fields with a single field, by extending the notation of one-to-one variable binding to many-to-one binding. We further present a formal way of detecting these possible misinterpretations, based on a Control Flow Analysis for this version of the calculus. The analysis over-approximates all the possible behaviour of a protocol, including those effected by these type confusions. As an example, we considered the amended Needham-Schroeder symmetric protocol, where we succeed in detecting the type confusion that lead to a complex type flaw attacks it is subject to. Therefore, the analysis can capture potential type confusions of this kind on security protocols, besides other security properties such as confidentiality, freshness and message authentication. © 2008 Springer-Verlag Berlin Heidelberg.","Gao, Han;Bodei, Chiara;Degano, Pierpaolo",22941011100;6603107885;7006345611
10.1007/978-3-540-68679-8_1,1,,"De Nicola, Rocco;Degano, Pierpaolo;Meseguer, José",7004298169;7006345611;7103153821
,0,,"De Nicola, Rocco;Degano, Pierpaolo;Meseguar, José",7004298169;7006345611;24401520400
10.1007/978-3-540-68894-5_10,2,"This paper reports on our experience in modelling whole cells with process calculi. We followed a holistic approach, aiming at investigating the behaviour of biological objects at the system level, in particular of a hypothetical and a of real prokaryote. These cells, namely VICE and Escherichia coli, have been specified through the π-calculus, endowed with a stochastic semantics. We describe a couple of variants of the π-calculus and briefly survey three interpreters of it, with increasing efficiency. We show how the usage of tools based on process calculi greatly helped us in designing the virtual cell VICE, and in comparing it with other prposals. The main properties of the in silico experiments on VICE and on Escherichia coli are then discussed and shown in agreement with those of real prokaryoptes acting in vivo/vitro. © 2008 Springer-Verlag Berlin Heidelberg.","Chiarugi, Davide;Degano, Pierpaolo;Van Klinken, Jan Bert;Marangoni, Roberto",22133780300;7006345611;57198249048;7004801777
,2,,"Bernardo, Marco;Degano, Pierpaolo;Zavattaro, Gianluigi",14038627200;7006345611;6701571633
10.1186/1471-2105-9-S4-S7,11,"Background: Research in life sciences is benefiting from a large availability of formal description techniques and analysis methodologies. These allow both the phenomena investigated to be precisely modeled and virtual experiments to be performed in silico. Such experiments may result in easier, faster, and satisfying approximations of their in vitro/vivo counterparts. A promising approach is represented by the study of biological phenomena as a collection of interactive entities through process calculi equipped with stochastic semantics. These exploit formal grounds developed in the theory of concurrency in computer science, account for the not continuous, nor discrete, nature of many phenomena, enjoy nice compositional properties and allow for simulations that have been demonstrated to be coherent with data in literature. Results: Motivated by the need to address some aspects of the functioning of neural synapses, we have developed one such model for synaptic processes in the calyx of Held, which is a glutamatergic synapse in the auditory pathway of the mammalia. We have developed such a stochastic model starting from existing kinetic models based on ODEs of some sub-components of the synapse, integrating other data from literature and making some assumptions about non-fully understood processes. Experiments have confirmed the coherence of our model with known biological data, also validating the assumptions made. Our model overcomes some limitations of the kinetic ones and, to our knowledge, represents the first model of synaptic processes based on process calculi. The compositionality of the approach has permitted us to independently focus on tuning the models of the pre- and post- synaptic traits, and then to naturally connect them, by dealing with ""interface"" issues. Furthermore, we have improved the expressiveness of the model, e.g. by embedding easy control of element concentration time courses. Sensitivity analysis over several parameters of the model has provided results that may help clarify the dynamics of synaptic transmission, while experiments with the model of the complete synapse seem worth explaining short-term plasticity mechanisms. Conclusions: Specific presynaptic and postsynaptic mechanisms can be further analysed under various conditions, for instance by studying the presynaptic behaviour under repeated activations. The level of details of the description can be refined, for instance by further specifying the neurotransmitter generation and release steps. Taking advantage of the compositionality of the approach, an enhanced model could then be composed with other neural models, designed within the same framework, in order to obtain a more detailed and comprehensive model. In the long term, we are interested, in particular, in addressing models of synaptic plasticity, i.e. activity dependent mechanisms, which are the bases of memory and learning processes. More on the computer science side, we plan to follow some directions to improve the underlying computational model and the linguistic primitives it provides as suggested by the experiments carried out, e.g. by introducing a suitable notion of (spatial) locality. © 2008 Bracciali et al.; licensee BioMed Central Ltd.","Bracciali, Andrea;Brunelli, Marcello;Cataldo, Enrico;Degano, Pierpaolo",8922231000;7005156454;23391832900;7006345611
10.1016/j.ic.2007.11.003,0,,"Degano, Pierpaolo;Küsters, Ralf;Viganò, Luca;Zdancewic, Steve",7006345611;7003544394;57208733404;57293474600
10.1109/TSE.2007.70740,51,"We outline a methodology for designing and composing services in a secure manner. In particular, we are concerned with safety properties of service behaviour. Services can enforce security policies locally and can invoke other services respecting given security contracts. This call-by-contract mechanism offers a significant set of opportunities, each driving secure ways to compose services. We discuss how to correctly plan services compositions in several relevant classes of services and security properties. To this aim, we propose a graphical modelling framework, based on a foundational calculus called lambda-req. Our formalism features dynamic and static semantics, so allowing for formal reasoning about systems. Static analysis and model checking techniques provide the designer with useful information to assess and fix possible vulnerabilities. © 2008 IEEE.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
10.1007/s10207-007-0038-6,0,,"Degano, Pierpaolo;Viganò, Luca",7006345611;57208733404
10.1016/j.entcs.2007.09.010,7,"A type flaw attack on a security protocol is an attack where an honest principal is cheated on interpreting a field in a message as the one with a type other than the intended one. In this paper, we shall present an extension of the LySa calculus with tags attached to each field, indicating the intended types. We developed a control flow analysis for analysing the extended LySa, which over-approximates all the possible behaviour of a protocol and hence is able to capture any type confusion that may happen during the protocol execution. The control flow analysis has been applied to a number of security protocols, either subject to type flaw attacks or not. The results show that it is able to capture type flaw attacks on those security protocols. © 2007 Elsevier B.V. All rights reserved.","Bodei, Chiara;Degano, Pierpaolo;Gao, Han;Brodo, Linda",6603107885;7006345611;22941011100;23395914900
10.1007/978-3-540-76929-3_15,14,"We present a reduction semantics for the LYSA calculus extended with session information, for modelling cryptographic protocols, and a static analysis for it. If a protocol passes the analysis then it is free of replay attacks and thus preserves freshness. The analysis has been implemented and applied to a number of protocols, including both original and corrected version of Needham-Schroeder protocol. The experiment results show that the analysis is able to capture potential replay attacks. © Springer-Verlag Berlin Heidelberg 2007.","Gao, Han;Bodei, Chiara;Degano, Pierpaolo;Nielson, Hanne Riis",22941011100;6603107885;7006345611;7004717061
10.1007/978-3-540-73940-1_3,18,"We consider BioAmbients, a calculus for specifying biological entities and for simulating and analysing their behaviour. We extend BioAmbients to take quantitative information into account by defining a stochastic semantics, based on a simulation stochastic algorithm, to determine the actual rate of transitions. © Springer-Verlag Berlin Heidelberg 2007.","Brodo, Linda;Degano, Pierpaolo;Priami, Corrado",23395914900;7006345611;7004501318
10.1007/978-3-540-75140-3_11,3,"We explore some presynaptic mechanisms of the calyx of Held synapse through a stochastic model. The model, drawn from a kinetic approach developed in literature, exploits process calculi as formal grounds, enjoys nice compositional properties, has a direct computational implementation that supports simulation trials, and, to our knowledge, represents the first process calculi based model of a presynaptic terminal. Simulation results have shown coherence with experimental data and robustness against sensitivity analysis. The core model has been extended in order to address some issues related to open problems: we discuss hypotheses on short-term synaptic enhancement (facilitation) and depression, i.e. plasticity mechanism that are related to memory and learning. The two aims of our work, i.e. addressing neural mechanisms and validating and possibly improving, process calculi based modeling techniques are discussed throughout the paper, together with the results of experiments. © Springer-Verlag Berlin Heidelberg 2007.","Bracciali, Andrea;Brunelli, Marcello;Cataldo, Enrico;Degano, Pierpaolo",8922231000;7005156454;23391832900;7006345611
10.1007/978-3-540-74810-6_2,14,"We present a framework for designing and composing services in a secure manner. Services can enforce security policies locally, and can invoke other services in a ""call-by-contract"" fashion. This mechanism offers a significant set of opportunities, each driving secure ways to compose services. We discuss how to correctly plan service orchestrations in some relevant classes of services and security properties. To this aim, we propose both a core functional calculus for services and a graphical design language. The core calculus is called λreg [10]. It features primitives for selecting and invoking services that respect given behavioural requirements. Critical code can be enclosed in security framings, with a possibly nested, local scope. These framings enforce safety properties on execution histories. A type and effect system over-approximates the actual run-time behaviour of services. Effects include the actions with possible security concerns, as well as information about which services may be selected at run-time. A verification step on these effects allows for detecting the viable plans that drive the selection of those services that match the security requirements on demand. © Springer-Verlag Berlin Heidelberg 2007.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
10.1007/978-3-540-71389-0_4,29,"An extension of the λ-calculus is proposed, to study resource usage analysis and verification. Resources can be dynamically created, and passed / returned by functions; their usages have side effects, represented by events. Usage policies are properties over histories of events, and have a possibly nested, local scope. A type and effect system over-approximates the set of histories a program can generate at run-time. A crucial point solved here concerns correctly associating fresh resources with their usages within approximations. A second issue is that these approximations may contain an unbounded number of fresh resources. Despite of that, we have devised a technique to model-check validity of approximations. A program with a valid approximation is resource-safe: no run-time monitor is needed to safely drive its executions. © Springer-Verlag Berlin Heidelberg 2007.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi;Zunino, Roberto",9536042900;7006345611;56221627000;8382815000
10.1371/journal.pcbi.0030174,14,"Comparative genomics usually involves managing the functional aspects of genomes, by simply comparing gene-by-gene functions. Following this approach, Mushegian and Koonin proposed a hypothetical minimal genome, Minimal Gene Set (MGS), aiming for a possible oldest ancestor genome. They obtained MGS by comparing the genomes of two simple bacteria and eliminating duplicated or functionally identical genes. The authors raised the fundamental question of whether a hypothetical organism possessing MGS is able to live or not. We attacked this viability problem specifying in silico the metabolic pathways of the MGS-based prokaryote. We then performed a dynamic simulation of cellular metabolic activities in order to check whether the MGS-prokaryote reaches some equilibrium state and produces the necessary biomass. We assumed these two conditions to be necessary for a living organism. Our simulations clearly show that the MGS does not express an organism that is able to live. We then iteratively proceeded with functional replacements in order to obtain a genome composition that gives rise to equilibrium. We ruled out 76 of the original 254 genes in the MGS, because they resulted in duplication from a functional point of view. We also added seven genes not present in the MGS. These genes encode for enzymes involved in critical nodes of the metabolic network. These modifications led to a genome composed of 187 elements expressing a virtually living organism, Virtual Cell (ViCe), that exhibits homeostatic capabilities and produces biomass. Moreover, the steady-state distribution of the concentrations of virtual metabolites that resulted was similar to that experimentally measured in bacteria. We conclude then that ViCe is able to ""live in silico."". © 2007 Chiarugi et al.","Chiarugi, Davide;Degano, Pierpaolo;Marangoni, Roberto",22133780300;7006345611;7004801777
10.1109/CSFW.2006.31,22,"A distributed calculus is proposed for describing networks of services. We model service interaction through a call-by-property invocation mechanism, by specifying the security constraints that make their composition safe. A static approach is then proposed to determine how to compose services and guarantee that their execution is always secure, without resorting to any dynamic check. © 2006 IEEE.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.1016/j.tcs.2006.08.031,0,,"Degano, Pierpaolo;Viganò, Luca",7006345611;57208733404
10.1016/j.entcs.2006.07.014,39,"The similarities between biological systems and distributed and mobile systems suggest that the theory of process calculi could be a useful starting point for understanding, if not predicting, the behaviour of complex biological systems. To formally model in vitro or in vivo experiments, appropriate quantitative extensions of process calculi have to be investigated. This paper focuses on Beta-binders, a language of processes with typed interaction sites which has been recently introduced to accurately represent biological entities. Here the syntax and semantics of Beta-binders are enriched to achieve a stochastic version of it, in order to obtain quantitative measures on biological phenomena. The quantitative parameters are derived from typed interaction sites introducing the concept of affinity. The relevance of quantitative reasoning is outlined running a biological example. © 2006 Elsevier B.V. All rights reserved.","Degano, P.;Prandi, D.;Priami, C.;Quaglia, P.",7006345611;14219711600;7004501318;7003974579
10.1007/11690634_28,4,"We present a static analysis technique for the verification of cryptographic protocols, specified in a process calculus. Rather than assuming a specific, fixed set of cryptographic primitives, we only require them to be specified through a term rewriting system, with no restrictions. Examples are provided to support our analysis. First, we tackle forward secrecy for a Diffie-Hellman-based protocol involving exponentiation, multiplication and inversion. Then, a simplified version of Kerberos is analyzed, showing that its use of timestamps succeeds in preventing replay attacks. © Springer-Verlag Berlin Heidelberg 2006.","Zunino, Roberto;Degano, Pierpaolo",8382815000;7006345611
10.1007/11885191_7,3,"We analyse an enhanced specification of VICE, a hypothetical prokaryote with a genome as basic as possible. Besides the most common metabolic pathways of prokaryotes in interphase, VICE also posseses a regulatory feedback circuit based on the enzyme phosphcfructokinase. We use as formal description language a fragment of the stochastic π-calculus. Simulations are run on BEAST, an abstract machine specially tailored to run in silico experimentations. Two kinds of virtual experiments have been carried out, depending on the way nutrients are supplied to VICE. The result of our experimentations in silico confirm that our virtual cell ""survives"" in an optimal environment, as it exhibits the homeostatic property similary to real living cells. Additionally, oscillatory patterns in the concentration of fructose-6-phosphate and fructose-1,6-bisphosphate show up, similar to the real ones. © Springer-Verlag Berlin Heidelberg 2006.","Chiarugi, D.;Chinellato, M.;Degano, P.;Lo Brutto, G.;Marangoni, R.",22133780300;15121965500;7006345611;15122297900;7004801777
10.1007/11768869_1,22,"We use a distributed, enriched λ-calculus for describing networks of services. Both services and their clients can protect themselves, by imposing security constraints on each other's behaviour. Then, service Interaction results in a call-by-property mechanism, that matches the client requests with service's. A static approach is also described, that determines how to compose services while guaranteeing that their execution Is always secure, without resorting to any dynamic check. © IFIP International Federation for Information Processing 2006.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.1109/CSFW.2005.17,37,"A static approach is proposed to study secure composition of software. We extend the λ-calculus with primitives for invoking services that respect given security requirements. Security-critical code is enclosed in policy framings with a possibly nested, local scope. Policy framings enforce safety and liveness properties of execution histories. The actual histories that can occur at runtime are over-approximated by a type and effect system. These approximations are model-checked to verify policy framings within their scopes. This allows for removing any runtime execution monitor, and for selecting those services that match the security requirements. © 2005 IEEE.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.1109/QEST.2005.13,0,"The similarities between systems of living entities and systems of concurrent processes may support biological experiments in silico. Process calculi offer a formal framework to describe biological systems, as well as to analyse their behaviour, both from a qualitative and a quantitative point of view. A couple of little examples help us in showing how this can be done. We mainly focus our attention on the qualitative and quantitative aspects of the considered biological systems, and briefly illustrate which kinds of analysis are possible. We use a known stochastic calculus for the first example. We then present some statistics collected by repeatedly running the specification, that turn out to agree with those obtained by experiments in vivo. Our second example motivates a richer calculus. Its stochastic extension requires a non trivial machinery to faithfully reflect the real dynamic behaviour of biological systems. © 2005 IEEE.","Curti, Michele;Degano, Pierpaolo;Prandi, Davide;Priami, Corrado;Quaglia, Paola;Brodo, Linda",7003550016;7006345611;14219711600;7004501318;7003974579;23395914900
10.1145/1045405.1045407,5,"A new model for access control is proposed, based on policy framings embedded into histories of execution. This allows for policies that have a possibly nested, local scope. In spite of the increased expressive power of our model, we present a way to use standard model checking for history verification. Copyright 2005 ACM.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.1007/11560586_9,5,"An extension of the λ-calculus is proposed to study history-based access control. It allows for parametrized security policies with a possibly nested, local scope. To govern the rich interplay between local policies, we propose a combination of static analysis and dynamic checking. A type and effect system extracts from programs a correct approximation to the histories obtainable at run-time. A further static analysis over these approximations determines how to instrument code so to enforce the desired security constraints. The execution monitor, based on finite-state automata, runs efficiently the instrumented code. © Springer-Verlag Berlin Heidelberg 2005.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.1016/j.entcs.2005.06.008,0,,"Degano, Pierpaolo;Viganò, Luca",7006345611;57208733404
10.1016/j.tcs.2005.03.006,6,We consider secrecy and authentication in a simple process calculus with cryptographic primitives. The standard Dolev-Yao adversary is enhanced so that it can guess the key required to decrypt an intercepted message. We borrow from the computational complexity approach the assumptions that guessing succeeds with a given negligible probability and that the resources available to adversaries are polynomially bounded. Under these hypotheses we prove that the standard Dolev-Yao adversary is as powerful as the enhanced one. © 2005 Elsevier B.V. All rights reserved.,"Zunino, Roberto;Degano, Pierpaolo",8382815000;7006345611
10.1016/j.entcs.2004.10.008,8,"We use a special operational semantics which helps us in predicting quantitative measures on systems describing cryptographic protocols: We also consider a possible attacker. The transitions of the system carry enhanced labels. We assign rates to transitions by only looking at these labels. We then map transition systems to Markov chains and evaluate performance of systems, using standard tools. © 2005 Elsevier B.V.","Bodei, Chiara;Curti, Michele;Degano, Pierpaolo;Priami, Corrado",6603107885;7003550016;7006345611;7004501318
10.1016/j.entcs.2004.01.017,7,"We use a special operational semantics which drives us in inferring quantitative measures on system describing cryptographic protocols. The transitions of the system carry enhanced labels. We assign rates to transitions by only looking at these labels. The rates reflect the distributed architecture running applications and the use of possibly different cryptosystems. We then map transition systems to Markov chains and evaluate performance of systems, using standard tools.","Bodei, Chiara;Curti, Michele;Degano, Pierpaolo;Buchholtz, Mikael;Nielson, Flemming;Riis Nielson, Hanne;Priami, Corrado",6603107885;7003550016;7006345611;8684914000;7003394505;7004717061;7004501318
10.1007/11535294_1,4,"We use an enhanced operational semantics to infer quantitative measures on systems describing cryptographic protocols. System transitions carry enhanced labels. We assign rates to transitions by only looking at these labels. The rates reflect the distributed architecture running applications and the use of possibly different crypto-systems. We then map transition systems to Markov chains and evaluate performance of systems, using standard tools. © Springer-Verlag Berlin Heidelberg 2005.","Bodei, Chiara;Buchholtz, Mikael;Curti, Michele;Degano, Pierpaolo;Nielson, Flemming;Nielson, Hanne Riis;Priami, Corrado",6603107885;8684914000;7003550016;7006345611;7003394505;7004717061;7004501318
10.1007/978-3-540-25974-9_16,13,"We report on the specification and analysis of VICE, a hypothetical cell with a genome as basic as possible. We used an enhanced version of the π-calculus and a prototype running it to study the behaviour of VICE. The results of our experimentation in silico confirm that our virtual cell ""survives"" in an optimal environment and shows a behaviour similar to that of real prokaryotes. © Springer-Verlag Berlin Heidelberg 2005.","Chiarugi, D.;Curti, M.;Degano, P.;Marangoni, R.",22133780300;7003550016;7006345611;7004801777
10.1007/978-3-540-31982-5_20,38,"An extension of the λ-calculus is proposed, to study history-based access control. It allows for security policies with a possibly nested, local scope. We define a type and effect system that, given a program, extracts a history expression, i.e. a correct approximation to the set of histories obtainable at run-time. Validity of history expressions is non-regular, because the scope of policies can be nested. Nevertheless, a transformation of history expressions is presented, that makes verification possible through standard model checking techniques. A program will never fail at run-time if its history expression, extracted at compile-time, is valid. © Springer-Verlag Berlin Heidelberg 2005.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.3233/JCS-2005-13302,97,"We methodically expand protocol narrations into terms of a process algebra in order to specify some of the checks that need to be made in a protocol. We then apply static analysis technology to develop an automatic validation procedure for protocols. Finally, we demonstrate that these techniques suffice to identify several authentication flaws in symmetric and asymmetric key protocols such as Needham-Schroeder symmetric key, Otway-Rees, Yahalom, Andrew Secure RPC, Needham-Schroeder asymmetric key, and Beller-Chang-Yacobi MSR. © 2005 - IOS Press and the authors. All rights reserved.","Bodei, Chiara;Buchholtz, Mikael;Degano, Pierpaolo;Nielson, Flemming;Nielson, Hanne Riis",6603107885;8684914000;7006345611;7003394505;7004717061
10.1016/j.future.2004.05.004,2,"We use two authentication primitives proposed recently as a linguistic support for enforcing authentication. They offer a way of abstracting from various specifications of authentication and of obtaining idealized protocols ""secure by construction"". Consequently, they help in proving that a cryptographic protocol correctly implements its corresponding abstract version; when the implementation is incorrect, suggestions on how to fix it may come from reasoning on the abstract specification. © 2004 Elsevier B.V. All rights reserved.","Bodei, Chiara;Degano, Pierpaolo;Focardi, Riccardo;Priami, C.",6603107885;7006345611;6701345241;7004501318
10.3233/JCS-2005-13103,4,"We introduce a Control Flow Analysis that statically approximates the dynamic behaviour of mobile processes, expressed in (a variant of) the π-calculus. Our analysis of a system is able to describe the essential behaviour of each sub-system, tracking where and between which sub-processes communications may occur. This means that we can safely approximate the behaviour of a system plugged in a larger and mainly unknown context, without explicitly analysing it Several possible properties can be investigated using this approximation, among which some related to confidentiality and to access control policies.","Bodei, Chiara;Degano, Pierpaolo;Priami, Corrado",6603107885;7006345611;7004501318
10.1016/j.tcs.2004.03.066,57,"We use the π-calculus to model the evolution of biochemical systems, taking advantage of their similarities with global computation applications. First, we present a reduction semantics for the π-calculus from which causality and concurrency can be mechanically derived. We prove that our semantics agrees with the causal definitions presented in the literature. We also extend our semantics to model biological compartments. Then, we show the applicability of our proposal on a couple of biological examples. © 2004 Elsevier B.V. All rights reserved.","Curti, M.;Degano, P.;Priami, C.;Baldari, C. T.",7003550016;7006345611;7004501318;7007006986
10.1016/j.entcs.2004.02.003,0,"A new static analysis is proposed for programming languages with access control based on stack inspection. This analysis allows for various security-aware program optimizations. A novel feature of our static analysis is that it is parametric with respect to the security policy in force, so it needs not to be recomputed when the access rights are dynamically updated. © 2004 Elsevier B.V. All rights reserved.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.1016/j.scico.2004.01.008,0,,"Degano, Pierpaolo",7006345611
10.1007/978-3-540-24727-2_36,7,We consider a secrecy property in a simple process calculus with cryptographic primitives. The standard Dolev-Yao attacker is enhanced so that it can guess the key for decrypting an intercepted message. We borrow from the computational complexity approach to secrecy the assumptions that guessing succeeds with a given negligible probability and that the resources available to attackers are polynomially bound. Under these hypotheses we prove that the standard Dolev-Yao attacker is as powerful as the enhanced one. © Springer-Verlag 2004.,"Zunino, Roberto;Degano, Pierpaolo",8382815000;7006345611
,7,"The replication operator was introduced by Milner for obtaining a simplified description of recursive processes. The standard interleaving semantics denotes the replication of a process P, written IP, a shorthand for its unbound parallel composition, operationally equivalent to the process P | P | . . . , with P repeated as many times as needed. Albeit the replication mechanism has become increasingly popular, investigations on its causal semantics has been scarce. In our work we consider the interleaving semantics for the operator proposed by Sangiorgi and Walker, and we show how to refine it in order to capture causality. Furthermore, we prove that a basic property usually associated to these semantics, the so-called concurrency diamond, does hold in our framework, and we sketch a correspondence between our proposal and the standard causal semantics for recursive process studied in the literature, for processes defined through constant invocations. © Springer-Verlag Berlin Heidelberg 2003.","Degano, Pierpaolo;Gadducci, Fabio;Priami, Corrado",7006345611;22733984100;7004501318
10.1007/3-540-36481-1_3,13,We present a reduction semantics for the π-calculus from which causality and concurrency can be mechanically derived. We prove that our semantics agrees with the causal definitions presented in the literature. We then apply the causal reduction semantics in the domain of biochemical systems to study the interactions of components.,"Curti, Michele;Degano, Pierpaolo;Tatiana Baldari, Cosima",7003550016;7006345611;7007006986
10.1007/3-540-36481-1_25,2,,"Degano, Pierpaolo;Priami, Corrado",7006345611;7004501318
,0,,"Degano, Pierpaolo",7006345611
10.1109/CSFW.2003.1212709,66,"We perform a systematic expansion of protocol narrations into terms of process algebra in order to make precise some of the detailed checks that need to be made in a protocol. We then apply static analysis technology to develop an automatic validation procedure for protocols. Finally, we demonstrate that these techniques suffice for identifying a number of authentication flaws in symmetric key protocols such as Needham-Schroeder, Otway-Rees, Yahalom and Andrew Secure RPC.","Bodei, C.;Buchholtz, M.;Degano, P.;Nielson, F.;Riis Nielson, H.",6603107885;8684914000;7006345611;7003394505;7004717061
10.1007/978-3-540-45145-7_5,0,"We advocate here the use of two authentication primitives we recently propose in a calculus for distributed systems, as a further instrument for programmers interested in authentication. These primitives offer a way of abstracting from various specifications of authentication and obtaining idealized protocols ""secure by construction"". We can consequently prove that a cryptographic protocol is the correct implementation of the corresponding abstract protocol; when the proof fails, reasoning on the abstract specification may drive to the correct implementation. © Springer-Verlag Berlin Heidelberg 2003.","Bodei, Chiara;Degano, Pierpaolo;Focardi, Riccardo;Priami, Corrado",6603107885;7006345611;6701345241;7004501318
10.1007/978-3-540-40042-4_8,4,"Global computing applications co-ordinate distributed computations across widely-dispersed hosts. Such systems present formidable design and implementation challenges to software developers and synchronisation, scheduling and performance problems come to the fore. Complex systems such as these can benefit from the application of high-level performance analysis methods founded on timed process algebras. In this paper we compare the use of two such approaches, the PEPA nets and EOS methods, illustrating our presentation with the example of modelling Web services.","Brodo, Linda;Degano, Pierpaolo;Gilmore, Stephen;Hillston, Jane;Priami, Corrado",23395914900;7006345611;8983764500;6602551227;7004501318
10.1007/978-3-540-40042-4_2,383,"We embed the transition system of the Mobile Ambients into the transition system of a subset of the π-calculus. The basic idea, applicable to other calculi as well, is to constrain the deduction of the π-calculus transitions with the suitable conditions that reflect the nesting of ambients. © Springer-Verlag Berlin Heidelberg 2003.","Brodo, Linda;Degano, Pierpaolo;Priami, Corrado",23395914900;7006345611;7004501318
10.1007/978-3-540-45208-9_28,0,"Stack inspection is a basic mechanism for implementing language based security. Stack inspection is time consuming and may prevent from code optimization. A static analysis is presented that safely approximates the access rights granted at run-rime. Stack inspection optimizations are then possible, along with program transformations. © Springer-Verlag Berlin Heidelberg 2003.","Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gian Luigi",9536042900;7006345611;56221627000
10.1016/S0304-3975(01)00136-0,15,"We extend the π-calculus and the spi-calculus with two primitives that guarantee authentication. They enable us to abstract from various implementations/specifications of authentication, and to obtain idealized protocols which are ""secure by construction"". The main underlying idea, originally proposed in Focardi (Proc. Sixth Italian Conf. on Theoretical Computer Science, November 1998) for entity authentication, is to use the locations of processes in order to check who is sending a message (authentication of a party) and who originated a message (message authentication). The theory of local names, developed in Bodei et al. (Theoret. Comput. Sci. 253(2) (2001) 155) for the π-calculus, gives us almost for free both the partner authentication and the message authentication primitives. © 2002 Elsevier Science B.V. All rights reserved.","Bodei, Chiara;Degano, Pierpaolo;Focardi, Riccardo;Priami, Corrado",6603107885;7006345611;6701345241;7004501318
10.1016/S1571-0661(04)00328-7,6,"We model, in a process algebra framework, a variant of the well known Wide Mouthed Frog security protocol. Its relevant security properties are addressed both from a dynamic and static point of view, having operational semantics as a common starting point. In one case, we exploit techniques based on Non-Interference, while in the other one we rely on Control Flow Analysis. We then compare these techniques. ©2002 Published by Elsevier Science B. V.","Bodei, Chiara;Degano, Pierpaolo;Focardi, Riccardo;Gorrieri, Roberto;Martinelli, Fabio",6603107885;7006345611;6701345241;7003394376;7006394072
10.1016/S0304-3975(01)00165-7,14,"We consider two operational semantics for CCS defined in the literature: the first exploits proved transition systems (PTS) and the second rewriting logic (RL). We show that the interleaving interpretation of both semantics agree, in that they define the same transitions and exhibit the same non-deterministic structure. In addition, we study causality in CCS computations. We recall its treatment via PTS, exhibiting the notion of causality presented in the literature, and we show how to recast it in the RL semantics via suitable axioms. Also in this case, the two semantics agree. © 2002 Elsevier Science B.V. All rights reserved.","Degano, Pierpaolo;Gadducci, Fabio;Priami, Corrado",7006345611;22733984100;7004501318
10.1016/S0167-739X(02)00047-X,12,"We introduce the νspi-calculus that strengthens the notion of ""perfect symmetric cryptography"" of the spi-calculus by making encryption history dependent. We give our calculus an operational and a static semantics. The latter is a control flow analysis (CFA), defined in the form of a flow logic, and it is proved semantically correct. We then apply our CFA to check security properties; in particular, we show that secrecy à la Dolev-Yao can be expressed in terms of the CFA. © 2002 Elseiver Science B.V. All rights reserved.","Bodei, C.;Degano, P.;Nielson, F.;Riis Nielson, H.",6603107885;7006345611;7003394505;7004717061
10.1109/32.962559,22,"We use a structural operational semantics which drives us in inferring quantitative measures on system evolution. The transitions of the system are labeled and we assign rates to them by only looking at these labels. The rates reflect the possibly distributed architecture on which applications run. We then map transition systems to Markov chains, and performance evaluation is carried out using standard tools. As a working example, we compare the performance of a conventional uniprocessor with a prefetch pipeline machine. We also consider two case studies from the literature involving mobile computation to show that our framework is feasible.","Nottegar, Chiara;Priami, Corrado;Degano, Pierpaolo",24078128900;7004501318;7006345611
10.1016/S1571-0661(04)00236-1,28,We propose two control flow analyses for the Java bytecode. They safely approximate the set of permissions granted/denied to code at run-time. This static information helps optimizing the implementation of the stack inspection algorithm. © 2001 Published by Elsevier Sciences B.V.,"Bartoletti, Massimo;Degano, Pierpaolo;Ferrari, Gianluigi",9536042900;7006345611;56221627000
10.1006/inco.2000.3020,64,"Control Flow Analysis is a static technique for predicting safe and computable approximations to the set of values that the objects of a program may assume during its execution. We present an analysis for the π-calculus that shows how names will be bound to actual channels at run time. The result of our analysis establishes a super-set of the set of channels to which a given name may be bound and of the set of channels that may be sent along a given channel. Besides a set of rules that permits one to validate a given solution, we also offer a constructive procedure that builds solutions in low polynomial time. Applications of our analysis include establishing two simple security properties of processes. One example is that P has no leaks: P offers communication to the external environment through public channels only and confines its secret channels within itself. The other example is connected to the no read up/no write-down property of Bell and LaPadula: once processes are given levels of security clearance, we check that a process at a high level never sends channels to processes at a lower level. © 2001 Academic Press.","Bodei, Chiara;Degano, Pierpaolo;Nielson, Flemming;Nielson, Hanne Riis",6603107885;7006345611;7003394505;7004717061
10.1016/S0304-3975(00)00093-1,12,"We address the problem of handling names in concurrent and distributed systems made up of mobile processes. We equip processes with local environments. Our structural operational semantics handles these environments so that captures of names are never possible. Our semantics includes the specification of a distributed name manager that conservatively extends standard operational semantics. Bisimulation-based equivalences can be checked on our transition systems. They yield the same equivalence relations as those based on standard interleaving semantics. Finally, we show that our development scales up smoothly to higher-order calculi. © 2001 Elsevier Science B.V. All rights reserved.","Bodei, Chiara;Degano, Pierpaolo;Priami, Corrado",6603107885;7006345611;7004501318
10.1007/3-540-44743-1_3,34,"We introduce the νSPI-calculus that strengthens the notion of “perfect symmetric cryptography” of the spi-calculus by taking time into account. This involves defining an operational semantics, defining a control flow analysis (CFA) in the form of a flow logic, and proving semantic correctness. Our first result is that secrecy in the sense of Dolev- Yao can be expressed in terms of the CFA. Our second result is that also non-interference in the sense of Abadi can be expressed in terms of the CFA; unlike Abadi we find the non-interference property to be an extension of the Dolev-Yao property.","Bodei, C.;Degano, P.;Nielson, F.;Nielson, H. Riis",6603107885;7006345611;7003394505;7004717061
10.1145/384192.384194,42,"This article surveys the definition and application of an enhancement of structural operational semantics in the field of concurrent systems, and also addresses issues of distribution and mobility of code. The focus is on how enriching the labels of transitions with encodings of their deduction trees is sufficient to derive qualitative and quantitative information on the systems in hand simply by relabeling the transitions of a unique concrete model. Categories and Subject Descriptors: D.3.1 [Programming Languages]: Formal Definitions and Theory-Semantics; C.2.4 [Computer-Communication Networks]: Distributed Systems; C.4 [Performance of Systems]: Modeling Techniques; D.2.1 [Software Engineering]: Requirements/Specifications; D.2.4 [Software Engineering]: Software/Program Verification; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Interactive and reactive computation, Parallelism and concurrency; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages-Operational semantics. ©2001 ACM.","Degano, Pierpaolo;Priami, Corrado",7006345611;7004501318
10.1007/3-540-44464-5_15,40,"We present a Control Flow Analysis (CFA) for the Safe Ambients, a variant of the calculus of Mobile Ambients. The analysis refines [12] and computes an approximation of the run-time topology of processes. We use the result of the analysis to establish a secrecy property.","Degano, Pierpaolo;Levi, Francesca;Bodei, Chiara",7006345611;7202914586;6603107885
10.1145/331499.382387,0,,"Degano, P.;Gorrieri, R.;Marchetti-Spaccamela, A.;Wegner, P.",7006345611;7003394376;7004071298;7005517088
10.1145/333580.333017,0,,"Degano, P.;Gorrieri, R.;Marchetti-Spaccamela, A.;Wegner, P.",7006345611;7003394376;7004071298;7005517088
10.1007/s002360050164,6,"Mobile agents, i.e. pieces of programs that can be sent around networks of computers, appear more and more frequently on the Internet. These programs may be seen as an enrichment of traditional distributed computing, and structuring applications using mobile agents is destined to become the de facto way of constructing distributed systems in the near future. Since mobile agents may carry communication links with them as they move across the network, they create very dynamic interconnection structures that can be extremely complex to analyse. In this paper we study an example of a system based on the mobile agent principle, written in the Facile programming language. We propose a Structural Operational Semantics (SOS) for Facile, giving a proved transition system that records encodings of the derivation trees of transitions in their labels. This information enables us to easily recover non-interleaving semantics for Facile by looking only at the labels of transitions. We use the new semantics to debug an agent based system. This example is a scaled down version of a system demonstrated at the European IT Conference Exhibition in Brussels, 1995. We also adopt our causal semantics to analyse the specification of a prefetch pipeline processor.","Degano, Pierpaolo;Priami, Corrado;Leth, Lone;Thomsen, Bent",7006345611;7004501318;6506603844;7006614572
10.1016/S0304-3975(99)80003-6,67,"This paper studies causality in the π-calculus. Our notion of causality combines the dependencies given by the syntactic structure of processes with those originated by passing names. Our studies show that two transitions not causally related may however occur in a fixed ordering in any computation, i.e., the π-calculus may implicitly express a precedence between actions. The same partial order of transitions is associated with all the computations that are obtained by shuffling transitions that are concurrent (i.e. related neither by causality nor by precedence). Other non-interleaving semantics are investigated and compared. The presentation takes advantage of a parametric definition of process behaviour given in SOS style that permits us to take almost for free the interleaving theory and tools. Finally, we extend our approach to higher-order π-calculus, enriched with a spawn operation. © 1999 - Elsevier Science B.V. All rights reserved.","Degano, Pierpaolo;Priami, Corrado",7006345611;7004501318
10.1007/978-3-540-49020-3_14,3,"We propose a structural operational semantics for mobile and distributed agents. From it we derive a stochastic transition system labelled by actions and their costs. These costs reflect the (net) architecture on which agents run. We then map stochastic transition systems to Markov chains, and performance evaluation is carried out using standard tools. The results of our approach are shown to agree with the ones obtained via classical evaluation techniques on a case study involving mobile computation.","Nottegar, Chiara;Priami, Corrado;Degano, Pierpaolo",24078128900;7004501318;7006345611
10.1007/3-540-49019-1_9,30,"We study a variant of the no read-up/no write-down security property of Bell and LaPadula for processes in the π-calculus. Once processes are given levels of security clearance, we statically check that a process at a high level never sends names to processes at a lower level. The static check is based on a Control Flow Analysis for the π -calculus that establishes a super-set of the set of names to which a given name may be bound and of the set of names that may be sent and received along a given channel, taking into account its directionality. The static check is shown to imply the natural dynamic condition.","Bodei, Chiara;Degano, Pierpaolo;Nielson, Flemming;Nielson, Hanne Riis",6603107885;7006345611;7003394505;7004717061
10.1109/CSFW.1999.779766,12,"We address the problem of message authentication using the Π-calculus, which has been given an operational semantics in [2] that provides each sequential process of a system with its own local space of names. We exploit here that semantics and its localized names to guarantee by construction that a message has been generated by a given entity. Therefore, our proposal can be seen as a reference for the analysis of “real” protocols. As an example, we study the way authentication is ensured by encryptingmessages in the spi-calculus [1].","Bodei, Chiara;Degano, Pierpaolo;Focardi, Riccardo;Priami, Corrado",6603107885;7006345611;6701345241;7004501318
10.1007/bfb0055617,58,"Control Flow Analysis is a static technique for predicting safe and computable approximations to the set of values that the objects of a program may assume during its execution. We present an analysis for the π-calculus that shows how names will be bound to actual channels at run time. The formulation of the analysis requires no extensions to the π-calculus, except for assigning ""channels"" to the occurrences of names within restrictions, and assigning ""binders"" to the occurrences of names within input prefixes. The result of our analysis establishes a super-set of the set of names to which a given name may be bound and of the set of names that may be sent along a given channel. Applications of our analysis include establishing simple security properties of processes. One example is that P has no leaks, i.e. P offers communication through public channels only, and confines its secret names within itself.","Bodei, Chiara;Degano, Pierpaolo;Nielson, Flemming;Nielson, Hanne Riis",6603107885;7006345611;7003394505;7004717061
10.1007/3-540-49727-7_10,1,"Most of the SOS semantics for concurrent systems can be derived by abstracting on the inference rules of a concrete transition system, namely the proved transition system. Besides the standard in-terleaving semantics we mechanically derive the causal transition system for CCS, whose definition is particularly dificult and paradigmatic. Its rules are shown to coincide with those presented in the literature. Also, the tree of its computations coincide with that obtained by abstracting the computations of the proved transition system. © 1998 Springer-Verlag Berlin Heidelberg.","Bodei, Chiara;Degano, Pierpaolo;Priami, Corrado",6603107885;7006345611;7004501318
10.1016/S1571-0661(05)80023-4,12,"We consider (a slight variant of) the ces calculus, and we analyze two operational semantics defined in the literature: the first exploits Proved Transition Systems (pts) and the second Rewriting Logic (rl). We show that the interleaving interpretation of both semantics agree, in that they define the same transitions and exhibit the same nondeterministic structure. In addition, we study causality in ces computations. We recall the treatment via pts, that exhibits the notion of causality presented in the literature, and we show how to recast it in the rl semantics via suitable axioms. © 1998 Published by Elsevier Science B. V.","Carabetta, Georgia;Degano, Pierpaolo;Gadducci, Fabio",55605015200;7006345611;22733984100
10.1016/S0096-0551(97)00016-7,1,"A taxonomy of syntax error handling techniques used in LR parsers is presented. The methods are classified according to the major features they offer. In particular, we distinguish correcting and noncorrecting techniques. The goal of the former methods is to correct an error when detected and to restart the parser. Instead, noncorrecting techniques simply signal the presence of an error and continue the analysis without attempting any correction on the source program. A finer classification of correcting approaches is given according the amount of information that is gathered around the error by the recovery routine. We distinguish phrase level, global and local techniques. Also interactive methods are considered. We report an evaluation of some techniques based on quality of the corrections, language independence, flexibility and efficiency. Finally, a glossary of technical terms is also provided. © 1998 Elsevier Science Ltd. All rights reserved.","Degano, Pierpaolo;Priami, Corrado",7006345611;7004501318
10.1007/3-540-62503-8_14,11,"We propose a structural operational semantics that expresses temporal aspects of mobile and distributed systems, each sequential component of which has its local clock. Since the run-time support of a programming language implements the operations of the language via some lower-level routines, the same action, put in different contexts, may have different durations. Also the network topology affects these durations, typically when messages are exchanged. We model this through a transition system labelled by actions and their costs, in a discrete time. Then, we define two performance preordings that say when the execution of a process is faster than that of another. The first preorder is similar to those presented in the literature, while the second refines it in that it considers a process faster than another if it is such from some point onwards of its execution. Finally, as an example we compare the performance of a conventional uniprocessor architecture with a prefetch pipeline architecture.","Degano, Pierpaolo;Loddo, Jean Vincent;Priami, Corrado",7006345611;23393344400;7004501318
10.1007/3-540-62503-8_1,2,,"Nielson, F.;Cousot, P.;Dam, M.;Degano, P.;Jouvelot, P.;Mycroft, A.;Thomsen, B.",7003394505;7003487004;7102845944;7006345611;6602775226;57204280835;7006614572
10.1007/3-540-62503-8_16,2,"Mobile agents, i.e. pieces of programs that can be sent around networks of computers, are starting to appear on the Internet. Such programs may be seen as an enrichment of traditional distributed computing. Since mobile agents may carry communication links with them as they move across the network, they create very dynamic interconnection structures that can be extremely complex to analyse. In this paper we apply a non-interleaving semantics to analyse a system based on the mobile agent principle written in the Facile programming language. This example is a scaled down version of a system demonstrated at the European IT Conference Exhibition in Brussels, 1995. This paper further develops a non-interleaving semantics for Facile, first presented in [4]. We develop a Structural Operational Semantics (SOS) for Facile, giving a proved transition system that records encodings of the derivation trees of transitions in their labels. This information allows us to easily recover non-interleaving semantics for Facile by looking only at the labels of transitions. This semantics may be instantiated to recover both causality and locality information.","Degano, Pierpaolo;Priami, Corrado;Leth, Lone;Thomsen, Bent",7006345611;7004501318;6506603844;7006614572
,0,,"Degano, Pierpaolo;Gorrieri, Roberto;Marchetti-Spaccamela, Alberto",7006345611;7003394376;7004071298
10.1007/BF03036469,1,"Descriptions of concurrent behaviors in terms of partial orderings (callednonsequential processes or simplyprocesses in Petri net theory) have been recognized as superior when information about distribution in space, about causal dependency or about fairness must be provided. However, at least in the general case of Place/Transition (P/T) nets, the proposed models lack a suitable, general notion ofsequential composition. In this paper, a new algebraic axiomatization is proposed, where, given a netN, a term algebraP[N] with two operations of parallel and sequential composition is defined. The congruence classes generated by a few simple axioms are proved isomorphic to a slight refinement of classical processes. Actually,P[N] is a symmetric strict monoidal category1, parallel composition is the monoidal operation on morphisms and sequential composition is morphism composition. BesidesP[N], we introduce a categorys[N] containing the classical occurrence and step sequences. The term algebras ofP[N] and ofs[N] are in general incomparable, thus we introduce two more categoriesK[N] and ℐ[N] providing an upper and a lower bound, respectively. A simple axiom expressing the functoriality of parallel composition mapsK[N] toP[N] ands[N] to ℐ[N], while commutativity of parallel composition mapsK[N] tos[N] andP[N] to ℐ[N] (see Fig. 4). Morphisms ofK[N] constitute a new notion of concrete net computation, while the strictly symmetric strict monoidal category ℐ[N] was introduced previously by two of the authors as a new algebraic foundation for P/T nets [22]. In the context of the present paper, the morphisms of ℐ[N] are proved isomorphic to the processes defined in terms of the “swap” transformation by Best and Devillers [5]. Thus the diamond of the four categories gives a full account in algebraic terms of the relations between interleaving and partial ordering observations of P/T net computations.","Degano, Pierpaolo;Meseguer, José;Montanari, Ugo",7006345611;7103153821;7004968272
10.1007/3-540-61739-6_36,8,"Mobile agents, i.e. pieces of programs that can be sent around networks of computers, are starting to appear on the Internet. Such programs may be seen as an enrichment of traditional distributed computing. Since mobile agents may carry communication links with them as they move across the network, they create very dynamic interconnection structures that can be extremely complex to analyse. In this paper we analyse a fragment of a system based on the mobile agent principle written in the Facile programming language. We propose a Structural Operational Semantics (SOS) for Facile, giving a proved transition system that records encodings of the derivation trees of transitions in their labels. This information allows us to easily recover non-interleaving semantics for Facile by looking only at the labels of transitions. We use the new Facile semantics to debug an agent based system. This example is a scaled down version of a system demonstrated at the European IT Conference Exhibition in Brussels, 1995.","Borgia, R.;Degano, P.;Priami, C.;Leth, L.;Thomsen, B.",57105301300;7006345611;7004501318;6506603844;7006614572
10.1007/3-540-61440-0_153,8,"We introduce local environments for mobile processes, expressed in π-calculus. Each local name is equipped with its relative address, i.e., with the information needed to point back to the process that generated it. Relative addresses are built upon the labels of the proved transition system of π-calculus. A router is specified that guarantees sound exportation of names.","Bodei, Chiara;Degano, Pierpaolo;Priami, Corrado",6603107885;7006345611;7004501318
10.1007/s002360050064,48,"Descriptions of concurrent behaviors in terms of partial orderings (called nonsequential processes or simply processes in Petri net theory) have been recognized as superior when information about distribution in space, about causal dependency or about fairness must be provided. However, at least in the general case of Place/Transition (P/T) nets, the proposed models lack a suitable, general notion of sequential composition. In this paper, a new algebraic axiomatization is proposed, where, given a net N, a term algebra script P sign [N] with two operations of parallel and sequential composition is defined. The congruence classes generated by a few simple axioms are proved isomorphic to a slight refinement of classical processes. Actually, script P sign[N] is a symmetric strict monoidal category1, parallel composition is the monoidal operation on morphisms and sequential composition is morphism composition. Besides script P sign[N], we introduce a category script capital L sign [N] containing the classical occurrence and step sequences. The term algebras of script P sign[N] and of script capital L sign [N] are in general incomparable, thus we introduce two more categories script K sign[N] and script T sign[N] providing an upper and a lower bound, respectively. A simple axiom expressing the functoriality of parallel composition maps script K sign[N] to script P sign[N] and script capital L sign[N] to script T sign[N], while commutativity of parallel composition maps script K sign[N] to script P sign[N] and (P[N] to script T sign[N] (see Fig. 4).","Degano, Pierpaolo;Meseguer, José;Montanari, Ugo",7006345611;7103153821;7004968272
10.1145/234528.234748,22,,"Degano, Pierpaolo;Priami, Corrado",7006345611;7004501318
10.3233/FI-1995-2236,0,"The random-assignment method for ensuring fairness for non-deterministic and/or concurrent languages is revised in order to make it dependent on the different priorities that each process may have. Priorities affect the choice of the scheduler in that a processes with high priority is preferred to others with a lower priority, still ensuring that all and only fair computations are originated. The actual presentation of the method is based on the non-standard model of the natural numbers of [C70]. © 1995 IOS Press. All rights reserved.","Degano, Pierpaolo",7006345611
10.1007/3-540-60084-1_113,32,"We study causality in the π-calculus. Our notion of causality combines the dependencies given by the syntactic structure of processes with those originated by passing names. It turns out that two transitions not causally related may although occur in a fixed ordering in any computation, i.e., π-calculus may express implicitly a priority between actions. Our causality relation still induces the same partial order of transitions for all the computations that are obtained by shuffling transitions that are concurrent (= related neither by causality nor by priority). The presentation takes advantage from a parametric definition of process behaviour that highlights the essence of the topic. All the results on bisimulation based equivalences, congruences, axiomatizations and logics axe taken (almost) for free from the interleaving theory.","Degano, Pierpaolo;Priami, Corrado",7006345611;7004501318
10.1007/3-540-60688-2_41,2,"We investigate some aspects of interexpressiveness of languages and their (denotational) semantic models by viewing semantic functions from a complexity-theory viewpoint. We classify semantic functions as polynomial or finite if a language term of size n produces a meta-language object respectively polynomially bounded in n or finite. Languages involving concurrency manifest most interest which we associate to the fact that their semantic models in general lack λ-style abstraction. The paper provides a quantifiable reason why labelled event structures form a more reasonable model for the choice and concurrency operators of CCS than do synchronisation trees. Similarly we show the representation of conflict by places within (at least occurrence forms of) Petri-nets is exponentially larger than the relational representation within corresponding event structures. An application is a criterion for selection of semantic models for real-world algorithmic purposes; for example, ‘model checking’ algorithms which use an exponentially larger semantic representation of programs are unlikely to be efficient.","Mycroft, Alan;Degano, Pierpaolo;Priami, Corrado",57204280835;7006345611;7004501318
10.1002/spe.4380250606,20,"Error recovery techniques for LR parsers presented in the literature are described and classified. The techniques considered range from the non‐correcting ones to interactive and incremental ones. Also, some of the techniques presented are compared and evaluated. An example showing the advantages and the disadvantages of each class of strategies is given and is used as a guideline for classifying syntax errors according to the recovery strategies which are more adequate to correct them. Copyright © 1995 John Wiley & Sons, Ltd","Degano, Pierpaolo;Priami, Corrado",7006345611;7004501318
10.1006/inco.1995.1142,15,"A TCSP-like concurrent language is extended with an operator for action refinement which plays a role similar to that of procedure-call for sequential languages. The language is given a denotational semantics that fully expresses causality in terms of Causal Trees. These are Synchronization Trees where each arc has a richer labelling containing, besides an action name, also the set of backward pointers to those arcs ""causing"" the present action. An operational semantics reflecting causality is also defined in SOS style by a causal transition system, the unfoldings of which are causal trees. The denotational and operational semantics agree up to causal bisimulation, which is proved to be a congruence for ail the operators of the calculus; notably, for the refinement operator. Also, a complete set of axioms is provided that characterizes the congruence classes of causal bisimulation for finite agents. The main result of the paper is an operational semantics firmly based on a view of action refinement as purely semantic substitution. Therefore, its operational definition provides a “parallel copy rule,” i.e., the concurrent analogous of the classic “copy rule” for sequential languages. © 1995 Academic Press, Inc.","Degano, Pierpaolo;Gorrieri, Roberto",7006345611;7003394376
10.1016/0304-3975(93)90361-V,31,"Refinement of actions allows one to design systems in a top-down style, changing the level of abstraction by interpreting actions on a higher level by more complicated processes on a lower level. We study action refinement in two connected models for true concurrency. The first model is an adaptation of prime event structures, called δ-free event structures. In this model refinement amounts to an expansion of events into event structures. Refinement is compatible with the history-preserving equivalence on event structures. The second model, called causal trees, is an explicit representation for event structures factored by history-preserving bisimulation. Causal trees are equipped with derived refinement operations, defined in an inductive way. The two models for refinement are shown to agree. Causal trees may, therefore, be used to construct a semantic calculus for algebras of process terms enriched with refinement, where terms are interpreted as classes of history-preserving equivalent event structures. © 1993.","Darondeau, Philippe;Degano, Pierpaolo",6604071113;7006345611
10.1016/0304-3975(93)90153-K,14,"Node-labelled graphs, called observation structures, are introduced as a basic model of concurrent distributed systems and as a framework for dealing with observational equivalences over them. In the special case of observation trees, the nodes represent the computations of a system and are labelled by what is observed out of them. The labelling function parametrically maps into different observation domains, e.g., sequences of actions, partial ordering, mixed ordering, ... A language for denoting observation trees is proposed and congruences over its terms are defined as strong, rooted branching and rooted weak bisimulations. Also a new bisimulation, called jumping bisimulation, is defined which naturally arises in the framework of state-labelled structures. Sound and complete axiomatizations, which are independent of the chosen observations, are exhibited for all bisimulations. It is claimed that most of the bisimulation-based congruences known in the literature, for a given process description language, can be recast in terms of congruences on observation structures, by carefully choosing both the bisimulation and the observation domain. Thus, the process of defining the extensional semantics of a process description language can be factorized into a few stages, for each of which several alternatives with clean rationales are available. © 1993.","Degano, Pierpaolo;De Nicola, Rocco;Montanari, Ugo",7006345611;7004298169;7004968272
10.1007/3-540-56610-4_53,10,,"Degano, Pierpaolo;Gorrieri, Roberto;Vigna, Sebastiano",7006345611;7003394376;56267340500
10.1007/3-540-56596-5_32,6,A very general notion of refinement of event structures is presented that refines both the events and the relations of causality and conflict. It is based on a purely semantic construction based on sections of a functor between domain-like categories. The present construction is compared to others in the literature.,"Degano, P.;Gorrieri, R.;Rosolini, G.",7006345611;7003394376;55944592600
10.1016/0164-1212(93)90061-2,3,"The incremental jump-shift-reduce (I_JSR) technique is an extension of LR techniques based on parsing table splitting suitable for generating analytic components of syntax-directed editors. I_JSR parsers provide a full analytic mode. Moreover, since the parsing table is split into smaller subtables, these may be stored as arrays, thus permitting faster access and accurate error handling. Users can interactively modify the input in any place without artful auxiliary data structures, and there is no need to maintain the parse tree throughout the translation process. This technique is used in developing integrated front-ends. A set of subtables is generated and is used by a single driver routine, which performs, in a fully incremental way, both lexical and syntactical analyses and exhibits high-quality error handling. The language lexicon is defined through a set of regular grammars that generate a collection of sets of I_JSR items. The construction of the set of states for the parser is more standard. We used the classic YACC parser generator, extended by a new package supporting incrementality. A further enhancement to these components is the integrated support for error detection and recovery. A new, automatically generated, possibly interactive method for error handling is presented. Its main features are high-quality corrections, its flexibility, and easy integration with the above-sketched components of the editor. © 1993.","Bianchi, U.;Degano, P.;Mannucci, S.;Martini, S.;Mojana, B.;Priami, C.;Salvatori, E.",7005401062;7006345611;6602649251;57214689442;6507106105;7004501318;57193911054
10.1007/3-540-55719-9_110,54,"An incremental parametric model is presented that permits to recover different descriptions of concurrent systems. Given a calculus, its semantics is defined through a privileged transition system with transitions labelled by their proofs; then computations, i.e., paths in the transition system, are given a tree structure (proved trees). Different representation of the behaviour of a process are obtained by observing, via an observation function, the proved tree associated to the process. As an example, the paper shows how the interleaving, causal, and locational semantics are recovered, and shows how the correspending bisimulations are compared, by a simple inspection of the used observation functions. Also, an algebra of proved trees is defined, and a generalized expansion law is exhibited. Through the appropriate observation function, this generalized law originates the analogous expansion law in the selected approach.","Degano, Pierpaolo;Priami, Corrado",7006345611;7004501318
,10,"A notion of semantic action refinement is defined both on Synchronization Trees and on Causal Trees, a class of trees recently devised for giving a full account to causality. The branching bisimulation, as introduced by Van Glabbeek et al. (1989), is shown to be preserved under semantic action refinement. As a by-product, the axiomatization of the congruence induced by branching bisimulation is still valid under action refinement. Both results hold for Synchronization Trees and, with the needed extensions, for Causal Trees.","Darondeau, P.;Degano, P.",6604071113;7006345611
10.1007/3-540-54345-7_55,16,"The hierarchical development of concurrent systems is investigated in a linguistic approach, by introducing a a new combinator for action refinement that substitutes a process for an action. In this way, the classic horizontal modularity is amalgamated with the new vertical one. The semantic definitions have been driven by two methodological criteria arising from a quest for compositionality that enforce to consider as atomic the behaviour of the processes refining actions. The first criterion requires that refinement must preserve the structure of the semantic object to be refined; the second one calls for a compositional refinement operation at the semantic level. Thus, refinement is not syntactic substitution, rather it is a compositional operation, which results to be context-free graph replacement of transition systems for transitions. The operational semantics implements this operation through states which are sort of stacks, used to make atomic the behaviour of processes refining actions; the denotational one uses tags expressing the start and the end of atomic sequences. Moreover, we define equivalences on both semantics, based on strong and rooted branching bisimulations, and we prove them congruences with respect to all the combinators of the language, and coincident.","Degano, Pierpaolo;Gorrieri, Roberto",7006345611;7003394376
10.1007/BFb0013471,4,"Bénabou’s notion of motor is extended to cover labelled finite trees. Operations on them are defined that permit to easily define the semantics for a finite concurrent calculus. Then, suitable motors that constructively define canonical representatives for strong and observational congruence based on the notion of bisimulation are introduced in a clean and straightforward way. This enables us to provide the calculus with a fully abstract semantics up to the above congruences.","Degano, P.;Kasangian, S.;Vigiia, S.",7006345611;12040384600;57195958558
10.1016/0304-3975(90)90095-Y,46,"A new operational semantics for ""pure"" CCS is proposed that considers the parallel operator as a first class one, and permits a description of the calculus in terms of partial orderings. The new semantics (also for unguarded agents) is given in the SOS style via the partial ordering derivation relation. CCS agents are decomposed into sets of sequential subagents. The new derivations relate sets of subagents, and describe their actions and the casual dependencies among them. The computations obtained by composing partial ordering derivations are ""observed"" either as interleaving or partial orderings of events. Interleavings coincide with Milner's many step derivations, and ""linearizations"" of partial orderings are all and only interleavings. Abstract semantics are obtained by introducing two relations of observational equivalence and congruence that preserve concurrency. These relations are finer than Milner's in that they distinguish interleaving of sequential nondeterministic agents from their concurrent execution. © 1990.","Degano, P.;De Nicola, R.;Montanari, U.",7006345611;7004298169;7004968272
10.1007/BFb0029614,13,,"Darondeau, Philippe;Degano, Pierpaolo",6604071113;7006345611
10.1007/3-540-53479-2_10,23,"Causal Trees are a variant of Milner's Synchronization Trees with enriched action labels which supply indication of the observable causes of observable actions, thus providing us with an interleaving description of concurrent systems which faithfully expresses causality. This model b~rrows from the interleaving models most of their mathematical simplicity and enhances their descriptive power. Actually, Labelled Event Structures can be easily translated to Causal Trees, maintaining all the causal structure the former express. Moreover, various notions of equivalences are defined on Causal Trees, among which those based on causal strong and weak bisimutation, and axiomatized. Also, history preserving bisimulation on Labelled Event Structures coincides with causal strong bisimulation, and a notion of weak history pre~rving bisimulation is induced by causal weak bisimulation.","Darondeau, Philippe;Degano, Pierpaolo",6604071113;7006345611
,67,"An algebraic axiomatization is proposed, where, given a net N, a term algebra P[N] with two operations of parallel and sequential composition is defined. The congruence classes generated by a few simple axioms are proved isomorphic to a slight refinement of classical processes. Actually, P[N] is a symmetric monoidal category, parallel composition is the monoidal operation on morphisms, and sequential composition is morphism composition. Besides P[N], the authors introduce a category S[N] containing the classical occurrence and step sequences. The term algebras of P[N] and S[N] are in general incomparable, and thus they introduce two more categories, K[N] and T[N], providing a most concrete and a most abstract extremum, respectively. The morphisms of T[N] are proved isomorphic to the processes recently defined in terms of the swap transformation by E. Best and R. Devillers (1987). Thus the diamond of the four categories gives a full account in algebraic terms of the relations between interleaving and partial ordering observations of place/transition net computations.","Degano, Pierpaolo;Meseguer, Jose;Montanari, Ugo",7006345611;7103153821;7004968272
10.1007/BFb0013030,75,"A methodology is introduced for defining truly concurrent semantics of processes as equivalence classes of Labelled Event Structures (LES). The construction of a les providing the operational semantics of systems consists of three main steps. First, systems are decomposed into sets of sequential processes and a set of rewriting rules is introduced which describe both the actions sequential processes may perform and their causal relation. Then, the rewriting rules are used to build an occurrence net. Finally, the required event structure is easily derived from the occurrence net. As a test case, a partial ordering operational semantics is introduced first for a subset of Milner's CCS and then for the whole calculus. The proposed semantics are consistent with the original interleaving semantics of the calculus and are able to capture all and only the parallelism present in its multiset semantics. In order to obtain more abstract semantic definitions, new notions of observational equivalence on Labelled Event Structures are introduced that preserve both concurrency and nondeterminism.","Degano, Pierpaolo;De Nicola, Rocco;Montanari, Ugo",7006345611;7004298169;7004968272
10.1007/BFb0035764,103,"The intent of the paper is to reconcile two antagonist views on bisimulation semantics for concurrency: the interleaving approach and the approach by partial orders. The so-called causal trees are a variant of Milner's synchronisation trees with enriched action labels which supply indication of the observable causes of observable actions. Concerning CCS, we construct an algebra of causal trees with two byproducts: a complete axiomatization of weak causal bisimulation between finite terms and a fully abstract model of recursive programs.","Darondeau, Ph;Degano, P.",6604071113;7006345611
,33,"The problem of the relationship between truly concurrent operational and denotational semantics is tackled by mapping syntactic terms on similar semantic domains in both approaches. Occurrence nets are associated to terms through a structured operational semantics based on a set of rewriting rules; event structures are defined as denotations for terms, without resorting to categorical constructions. The proof of the equivalence of the two semantics relies on the direct correspondence between occurrence nets and event structures. R. Milner's (1980) calculus of communicating systems is used as a test case; truly concurrent denotational and operational semantics are given for it and proved consistent. This equivalence is established for the first time in true concurrency approach. It is proved that G. Winskel's (1982) categorical denotational semantics is equivalent to that given here.","Degano, Pierpaolo;De Nicola, Rocco;Montanari, Ugo",7006345611;7004298169;7004968272
10.1007/BF02915446,111,"A new set of inference rules for the guarded version of Milner's Calculus of Communicating Systems is proposed. They not only describe the actions agents may perform when in a given state, but also say which parts of the agents move when the global state changes. From the transition relation a particular Petri Net, namely a Condition/Event system called ΣCCS, is immediately derived. Our construction gives a semantics which is consistent with the interleaving semantics of CCS and exhibits full parallelism. The proof consists of relating the case graph of ΣCCS with the original and with the multiset (step) transition systems of the calculus. © 1988 Springer-Verlag.","Degano, Pierpaolo;De Nicola, Rocco;Montanari, Ugo",7006345611;7004298169;7004968272
10.1145/44501.214503,18,"A technique for generating parsers which is an extension to LR techniques and is based on parsing table splitting, is presented. Then this technique is slightly extended to support incremental syntax analysis. Given a context-free grammar and a set “IC” of nonterminals devised to be incremental, a set of subtables is generated to drive the analysis of program fragments derivable from nonterminals in IC. The proposed technique generates parsing tables which are considerably smaller than the standard ones, even when incrementality is not exploited. Thus, these tables may be stored as arrays permitting faster access and accurate error handling. Furthermore, our tables are suitable for generating syntax-directed editors which provide a full analytic mode. The efficiency of the analytic component of a syntax-directed editor obtained in this way and its easy integration with the generative component stress the advantages of incremental program writing. © 1988, ACM. All rights reserved.","Degano, Pierpaolo;Mannucci, Stefano;Mojana, Bruno",7006345611;6602649251;6507106105
10.1007/BF01388999,1,"Labelled rewriting systems are shown to be powerful enough for defining the semantics of concurrent systems in terms of partial orderings of events, even in the presence of non standard operators like N that is not expressible by means of concurrency and sequentialization. This contrasts with Pratt's claim.(1) The main operators proposed by Pratt are used here to construct terms denoting concurrent systems, the behavior of which consists of partially ordered multisets defined operationally.(2) Fully abstractness of the denotational semantics as defined in Ref. 1 with respect to the operational one is finally proved. © 1987 Plenum Publishing Corporation.","Degano, Pierpaolo;Marchetti, Sergio",7006345611;24369988400
10.1145/23005.24038,72,"In our model, a graph describes a net of processes communicating through ports and, at the same time, its computation history consisting of a partial ordering of events. Stand-alone evolution of processes is specified by context-free productions. From productions and a basic synchronization mechanism, a set of context-sensitive rewriting rules that models the evolution of processes connected to the same ports can be derived. A computation is a sequence of graphs obtained by successive rewritings. The result of a finite computation is its last graph, whereas the result of an infinite computation is the limit, infinite graph defined through a completion technique based on metric spaces. A result characterizes a concurrent computation, since it abstracts from any particular interleaving of concurrent events, while in the meantime providing information about termination, partial or complete deadlocks, and fairness. Not every result is acceptable, however, but only the computations that produce a result no longer rewritable are successful. Infinite successful computations are shown to coincide with weakly fair computations, and a scheduler yielding all and only such computations is defined. © 1987, ACM. All rights reserved.","Degano, Pierpaolo;Montanari, Ugo",7006345611;7004968272
10.1007/3-540-18419-8_13,28,"A new class of Petri Nets, called Augmented Condition/Event Systems is defined, by slightly relaxing the condition for enabling events. One system, called ΣCCS, from this class is used to give a new operational semantics to Milner's Calculus of Communicating Systems. The set of CCS agents together with the traditional, interleaving based, derivation relation is proved isomorphic to the case graph of ΣCCS (when single transitions only are considered). Our achievement is twofold: first, we provide CCS with a semantics which is able to describe concurrency and causal dependencies between the actions the various agents can perform; second, we guarantee an adequate linguistic level for the particular class of Petri Nets which can be defined through CCS operators.","Degano, Pierpaolo;De Nicola, Rocco;Montanari, Ugo",7006345611;7004298169;7004968272
,0,"An extension to LR techniques based on parsing table splitting is presented and applied to generate incremental parsers. Given a context-free grammar and a set IC of nonterminals devised to be incremental, a set of subtables is generated to drive the analysis of program fragments derivable from nonterminals in IC. This technique generates parsing tables which are considerably smaller than the standard tables. Furthermore these tables are suitable for generating syntax-directed editors which provide a full analytic mode. The efficiency of the analytic component of the editor and the easy integration with the generative one stresses the advantages of incremental program writing.","Degano, Pierpaolo;Mannucci, Stefano;Mojana, Bruno",7006345611;6602649251;6507106105
10.1016/0022-0000(87)90032-8,60,"A new notion of transition systems, called distributed transition systems, is introduced, where states are sets of processes and transitions specify which processes stay idle. A notion of observations based on partial orderings, called concurrent histories, is defined on computations. Several observational equivalences, e.g., bisimulation, are given on observations. As case studies, Petri C/E systems and P/T nets, and Milner's CCS are translated to distributed transition systems. © 1987.","Degano, Pierpaolo;Montanari, Ugo",7006345611;7004968272
,0,"This chapter provides a general approach to the modelling of spatial and temporal aspects of concurrent systems. The main topics are Labelled transition systems, concurrent transition systems, synchronized concurrent transition systems, distributed port-synchronized transition systems, distributed synchronized transition systems, and tail-recursive grammars for distributed systems.","Degano, Pierpaolo;Montanari, Ugo",7006345611;7004968272
10.1007/3-540-15198-2_3,8,"Requirements of specification languages for distributed systems are considered, and a two level approach based on a kernel metalanguage and many application-oriented extensions is advocated. The method is applied to some models developed by the authors, organized in a tree-like refinement structure.","Degano, Pierpaolo;Montanari, Ugo",7006345611;7004968272
10.1007/BFb0028836,47,"In this paper we extend CCS transitions, labelled by strings, to concurrent histories, i.e. to transitions labelled by partial orderings. The two notions are linked by a theorem which shows that the strings can be obtained by taking all interleavings compatible with the partial orderings.","Degano, Pierpaolo;De Nicola, Rocco;Montanari, Ugo",7006345611;7004298169;7004968272
10.1109/TPAMI.1985.4767619,2,"A noninductive method for mechanical theorem proving is presented, which deals with a recursive class of theorems involving iterative functions and predicates. The method is based on the symbolic evaluation of the formula to be proved and requires no inductive step. Induction is avoided since a metatheorem is proved which establishes the conditions on the evaluation of any formula which are sufficient to assure that the formula actually holds. The proof of a supposed theorem consists in evaluating the formula and checking the conditions. The method applies to assertions that involve element-by-element checking of typed homogeneous sequences which are hierarchically constructed out of the primitive type consisting of the truth values. The sequences can be computed by means of iterative and “accumulator” functions. The paper includes the definition of a simple typed iterative language in which both predicates and functions are expressed. The language precisely defines the scope of the proof method. The method proves a wide variety of theorems about iterative functions on sequences, including that which states that REVERSE is its own inverse, and that it can be inversely distributed on APPEND, that FLATTEN can be distributed on APPEND and that each element of any sequence is a MEMBER of the sequence itself. Although the method is not complete, it does provide the basis for an extremely efficient tool to be used in a complete mechanical theorem prover. Copyright © 1985 by The Institute of Electrical and Electronics Engineers, Inc.","Degano, Pierpaolo;Sirovich, Franco",7006345611;6505861447
,5,The paper presents a design methodology to systematically derive an experimental program development environment. The generation of tools dealing with the syntactical aspects of both the programming languages and the data base is first outlined. The rest of the paper describes the derivation of analysis and execution tools from the definition of the programming language semantics. An example is presented which shows the derivation of some semantic tools for a simple language. The same methodology applies to the language extensions concerned with program data base manipulation (e. g. configuration management). The problems concerned with the transformation of denotational interpreters into efficient tools and with interactive debugging are then considered.,"Barbuti, R.;Bellia, M.;Degano, P.;Levi, G.;Dameri, E.;Simonelli, C.;Martelli, A.",7003474965;6701329060;7006345611;7201810836;6507467090;7005566587;7201881964
10.1007/978-3-642-82017-5_12,0,Presents rather tendentiously Artificial Intelligence as the study of those methods and ideas on which reliable and usable computer tools are based and implemented. -from Author,"Degano, P.",7006345611
,3,,"Barbuti, Roberto;Bellia, Marco;Martelli, Alberto;Dameri, Enrico;Simonelli, Carlandrea;Degano, Pierpaolo;Levi, Giorgio",7003474965;6701329060;7201881964;6507467090;7005566587;7006345611;7201810836
,6,,"Bellia, Marco;Degano, Pierpaolo;Levi, Giorgio;Dameri, Enrico;Martelli, Maurizio",6701329060;7006345611;7201810836;6507467090;8241362900
10.1007/3-540-11494-7_1,2,"We describe a first order applicative language for the specification of deterministic systems of communicating computing agents à la Kahn-MacQueen. Both the sequential and parallel interpreter we give are based on lazy evaluation, are demand driven and can handle infinite streams and non-terminating procedures. An equivalent least fixed-point semantics is then presented which neatly copes with the above features of the language. It is worth noting that computations in our logical based model can be considered as formal proofs, thus making formal reasoning about programs easier.","Bellia, Marco;Degano, Pierpaolo;Levi, Giorgio;Dameri, Enrico;Martelli, Maurizio",6701329060;7006345611;7201810836;6507467090;8241362900
10.1007/BFb0022507,1,"The paper presents a formal model to specify a data base, a query and the access path which must be followed to obtain the ansewer. The model is based on the problem reduction hypergraphs, for which an admissible and optimal search algorithm is known. An effective method is given to map the data base and the query into a problem reduction hypergraph, which the known search algorithm can be applied to. The optimal solution to the problem reduction hypergraph provides an optimal (and possibly parallel) program to obtain the answer to the given query. Since the model allows to determine the correct answer, if any, without modifications of the data base nor requiring further information, it is an improvement over the models presented in the literature.","Degano, P.;Lomanto, A.;Sirovich, F.",7006345611;6506753094;6505861447
10.1007/BF01933197,0,,"Degano, P.;Pacini, G.;Turini, F.",7006345611;7005186044;7004433304
,8,"An interactive programming system is described which provides an integrated collection of tools for dealing with the whole process of program development. The pivot tool, the symbolic interpreter, may cover a broad range of applications, from testing to correctness proving. The aspects in which the symbolic interpreter differs from a conventional interpreter, i. e. , the possibility of handling nondeterministic branching at choice points and the presence of a system for manipulating symbolic expressions, are described. Furthermore, the main features of a programming language, around which the programming system is built, are presented.","Asirelli, P.;Degano, P.;Levi, G.;Martelli, A.;Montanari, U.;Pacini, G.;Sirovich, F.;Turini, F.",6603339511;7006345611;7201810836;7201881964;7004968272;7005186044;6505861447;7004433304
10.1007/BF02575967,1,"The paper introduces a class of recursive non-deterministic schemata, whose expressive power overcomes the capability of the recursive non-deterministic schemata defined so far. This class is a proper extension of Kowalski""s Predicate Logic, since our formalism allows a procedure declaration schema to have a conjunction rather than a single atomic formula in its left-hand side. It is worth noting that only introducing this feature it becomes possible to express, in a purely syntactic way, complex control structures related both to parallelism (cooperation, synchronization, coroutining, etc.) and to artificial intelligence problems (control of non-determinism via contexts, evaluation strategies, «continuation point» dealing, etc.). Finally the paper shows that the expressive power of the program schemata defined above is maximum. © 1977 Instituto di Elaborazione della Informazione del CNR.","Degano, P.",7006345611
